<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="https://powers-hell.com/feed.xml" rel="self" type="application/atom+xml" /><link href="https://powers-hell.com/" rel="alternate" type="text/html" /><updated>2022-09-11T12:05:02+00:00</updated><id>https://powers-hell.com/feed.xml</id><title type="html">Powers Hell</title><subtitle>great/power/is/great/fun &gt;</subtitle><entry><title type="html">Calculate &amp;amp; Validate MD5 hashes on Azure blob storage files with PowerShell</title><link href="https://powers-hell.com/2021/12/31/calculate-validate-md5-hashes-on-azure-blob-storage-files-with-powershell/" rel="alternate" type="text/html" title="Calculate &amp;amp; Validate MD5 hashes on Azure blob storage files with PowerShell" /><published>2021-12-31T00:39:00+00:00</published><updated>2021-12-31T00:39:00+00:00</updated><id>https://powers-hell.com/2021/12/31/calculate-validate-md5-hashes-on-azure-blob-storage-files-with-powershell</id><content type="html" xml:base="https://powers-hell.com/2021/12/31/calculate-validate-md5-hashes-on-azure-blob-storage-files-with-powershell/"><![CDATA[<p>I was recently asked to implement a solution to verify the integrity of a file stored in an Azure blob storage container. What started out as a frustrating task ended up being a really cool solution that I wanted to share with everyone!</p>

<!--more-->

<p>The obvious answer to this task is to compare a known file hash value against the actual file. This is fairly trivial to do with PowerShell.</p>

<pre><code class="language-PowerShell">Get-FileHash -Path C:\PathToYour\File.ext -Algorithm MD5
</code></pre>

<p>Running the above command will return the computed file hash of whatever you point it at. Comparing it to a known file hash will confirm if the file has been altered / corrupted in any way.</p>

<p><a href="/assets/images/2021/12/getfilehash.gif" title="Get-FileHash"><img src="/assets/images/2021/12/getfilehash.gif" alt="Get-FileHash" /></a></p>

<p>Here, I’ve run the command against a simple text file and have made a note of the file hash.</p>

<p>Simple, right?</p>

<p>Now, let’s go ahead and upload the same file to an Azure storage account.</p>

<p>When you do this from the portal, a file hash is automatically computed and stored as an exposable piece of metadata against the file. In theory, knowing that nothing about the file has changed, the hash we computed locally should match the hash computed in Azure.</p>

<p><a href="/assets/images/2021/12/contentmd5.png" title="content-md5"><img src="/assets/images/2021/12/contentmd5.png" alt="content-md5" /></a></p>

<p>HANG ON A SECOND.. those two MD5 hash values don’t match! Did something happen during the upload process? Was the file corrupted?</p>

<p>Not at all, thankfully!</p>

<p>Azure stores the file hash value in the <strong>CONTENT-MD5</strong> tag as a <strong>base64 encoded representation of the binary MD5 hash value</strong>, whereas when we compute the MD5 value locally, the output of the hash is a <strong>hex representation of the binary hash value</strong>…</p>

<p><a href="/assets/images/2021/12/what.webp" title="WHAT????"><img src="/assets/images/2021/12/what.webp" alt="WHAT????" /></a></p>

<p>Don’t worry if that flew over your head. The simple answer it is IS technically the same value, we just need to figure out how to “de hex” the result from our initial PowerShell command and convert it to a base64 string.</p>

<p>Thankfully, this is a fairly trivial process and I’ve found a <a href="https://galdin.dev/blog/md5-has-checks-on-azure-blob-storage-files/">great article</a> written by <a href="https://twitter.com/gldraphael">Galdin Raphael</a> discussing the EXACT situation I found myself facing. The only issue was that the code and tools mentioned in the article were for *nix environments..</p>

<p>If we look at the solution proposed by Galdin, for anyone not experienced in using *nix based tools, it can look a little confusing..</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">md5sum</span> <span class="nt">--binary</span> <span class="nv">$filename</span> | <span class="nb">awk</span> <span class="s1">'{print $1}'</span> | xxd <span class="nt">-p</span> <span class="nt">-r</span> | <span class="nb">base64</span>
</code></pre></div></div>

<p>It is infact very simple. Let’s split each command out at the pipe and look at what’s happening.</p>

<table>
  <thead>
    <tr>
      <th>command</th>
      <th>Explanation</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">md5sum --binary $filename</code></td>
      <td>This is the same result as running <code class="language-plaintext highlighter-rouge">Get-FileHash</code>. <br />This will return our hex representation of the MD5 hash</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">awk '{print $1}'</code></td>
      <td>This is just stripping out everything except for the hash.</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">xxd -p -r</code></td>
      <td>This command is doing a “reverse” hex dump and outputting<br /> the result in plain text (Converting back FROM hex to binary).</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">base64</code></td>
      <td>This command is encoding the binary result into base64</td>
    </tr>
  </tbody>
</table>

<p>So now we know how to functionally do this, let’s write it out in PowerShell!</p>

<pre><code class="language-PowerShell">function Get-ComputedMD5 {
    [cmdletbinding()]
    param (
        [parameter(Mandatory = $true)]
        [System.IO.FileInfo]$FilePath
    )
    try {
        $rawMD5 = (Get-FileHash -Path $FilePath -Algorithm MD5).Hash
        $hashBytes = [system.convert]::FromHexString($rawMD5)
        return [system.convert]::ToBase64String($hashBytes)
    }
    catch {
        Write-Warning $_.Exception.Message
    }
}
</code></pre>

<p>Pretty simple, isn’t it?!</p>

<p>Now that we know <em>how</em> to reencode the file hashes, let’s look at how we could implement this in a real world scenario.</p>

<h2 id="verify-the-file-hash-is-the-same-after-download">Verify the file hash is the same AFTER download</h2>

<p>This example will use the <code class="language-plaintext highlighter-rouge">Get-ComputedMD5</code> example from above to grab the MD5 hash from the storage container, download the file and confirm the local file hash matches the remote hash. If there is any mismatch during the download, we will delete the file.</p>

<pre><code class="language-PowerShell">function Get-RemoteFileAndConfirmHashValidationLocally {
    [cmdletbinding()]
    param (
        [parameter(Mandatory = $true)]
        [uri]$FileUrl,

        [parameter(Mandatory = $true)]
        [System.IO.FileInfo]$OutputFolder
    )

    try {
        $fileDownload = Invoke-WebRequest -Method Get -Uri $FileUrl
        if ($fileDownload.StatusCode -ne 200) { throw [System.Net.WebException]::new('Failed to download content') }
        $fileDownload.Content | Out-File "$OutputFolder\$($FileUrl.Segments[-1])"
        $localHash = Get-ComputedMD5 -FilePath "$OutputFolder\$($FileUrl.Segments[-1])"
        if ($localHash -ne $fileDownload.Headers['Content-MD5']) {throw [System.Net.WebException]::new('hash mismatch.')}
    }
    catch [System.Net.WebException] {
        Write-Warning $_.Exception.Message
        Remove-Item -Path "$OutputFolder\$($FileUrl.Segments[-1])"
    }
    catch {
        Write-Warning $_.Exception.Message
    }
}
</code></pre>

<hr />

<h2 id="bonus-round-verify-the-file-hash-is-the-same-before-download">BONUS ROUND: Verify the file hash is the same BEFORE download</h2>

<p>This example doesn’t compute the hash, but assumes you already have the MD5 hash and simply want to make sure the file in the storage container matches.<br />
A great way to confirm remote content hasn’t been tampered with!</p>

<pre><code class="language-PowerShell">function Get-RemoteFileIfHashIsKnown {
    [cmdletbinding()]
    param (
        [parameter(Mandatory = $true)]
        [uri]$FileUrl,

        [parameter(Mandatory = $true)]
        [string]$MD5,

        [parameter(Mandatory = $true)]
        [System.IO.FileInfo]$OutputFolder
    )
    try {
        $hashCheck = Invoke-WebRequest -Method Head -Uri $FileUrl
        if ($hashCheck.StatusCode -ne 200) { throw [System.Net.WebException]::new('Failed to get header content.') }

        Write-Host "Remote Hash: " -ForegroundColor Cyan -NoNewline
        Write-Host "$($hashCheck.Headers['Content-MD5'])" -ForegroundColor Green
        Write-Host "Known Hash: " -ForegroundColor Cyan -NoNewline
        Write-Host "$($MD5)" -ForegroundColor $(($hashCheck.Headers['Content-MD5'] -ne $MD5) ? "red" : "green")

        if ($hashCheck.Headers['Content-MD5'] -ne $MD5) { throw [System.Net.WebException]::new("hash mismatch") }

        Invoke-RestMethod -Method Get -Uri $FileUrl -OutFile "$OutputFolder\$($FileUrl.Segments[-1])"
    }
    catch {
        Write-Warning $_.Exception.Message
    }
}
</code></pre>

<hr />

<p>Thanks for sticking around for this one. I had a lot of fun figuring this out, and I hope it helps others out!</p>

<p>As always, code referenced in this post is available on <a href="https://github.com/tabs-not-spaces/CodeDump/tree/master/FIleHashValidation">GitHub</a>.</p>

<p>For all of you that are lucky enough to get time off, have a safe break &amp; I’ll see you all again for a hopefully MUCH better 2022.</p>

<p>— Ben</p>]]></content><author><name>Ben</name></author><category term="PowerShell" /><category term="Azure" /><category term="Automation" /><category term="PowerShell" /><category term="Azure" /><category term="Automation" /><summary type="html"><![CDATA[I was recently asked to implement a solution to verify the integrity of a file stored in an Azure blob storage container. What started out as a frustrating task ended up being a really cool solution that I wanted to share with everyone!]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://powers-hell.com/assets/images/2021/12/getremotehashmatch.gif" /><media:content medium="image" url="https://powers-hell.com/assets/images/2021/12/getremotehashmatch.gif" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Manage Intune Trusted Certificate Profile Expiration with PowerShell &amp;amp; Microsoft Graph</title><link href="https://powers-hell.com/2021/12/27/manage-intune-trusted-certificate-profile-expiration-with-powershell/" rel="alternate" type="text/html" title="Manage Intune Trusted Certificate Profile Expiration with PowerShell &amp;amp; Microsoft Graph" /><published>2021-12-27T04:36:00+00:00</published><updated>2021-12-27T04:36:00+00:00</updated><id>https://powers-hell.com/2021/12/27/manage-intune-trusted-certificate-profile-expiration-with-powershell</id><content type="html" xml:base="https://powers-hell.com/2021/12/27/manage-intune-trusted-certificate-profile-expiration-with-powershell/"><![CDATA[<p>How do you remind yourself to renew your CA root certificates / subordinate certificates? Do you set a calendar reminder? Did the person who set those reminders up forget to share them with the team and now is on holidays?</p>

<p>Fear not, for I have holiday gift for you - using nothing but PowerShell, we can interrogate our <strong>trusted certificate policies</strong> and, as if by magic, send out alerts when the attached certificates are about to expire!</p>

<!--more-->

<p>Ready? Let’s dive right in.</p>

<h2 id="overview">Overview</h2>

<p>At a high level, what we need to do here is very simple.</p>

<p>All trusted certificate policies store the certificates in a <strong>base64</strong> encoded string. If we can get access to the policy, we can decrypt the string and interrogate the certificate metadata for its expiry time. Luckily for us, using Microsoft Graph makes this process almost painless.</p>

<h2 id="authentication">Authentication</h2>

<p>Ah my favourite topic. Yes, as always, the first step to Intune automation is authentication. Go read my previous article on Graph authentication with PowerShell if you haven’t already.</p>

<p>If you don’t have an AAD application registered yet, <a href="https://docs.microsoft.com/en-us/azure/active-directory/develop/quickstart-register-app">go ahead and create one.</a>.<br />
The minimum API permissions you will need are listed below..</p>

<table>
  <thead>
    <tr>
      <th>API Permission Name</th>
      <th>Type</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>DeviceManagementManagedDevices.Read.All</td>
      <td>Application</td>
    </tr>
  </tbody>
</table>

<p>Make sure you grant admin consent for the above permission.<br />
Next, generate a <strong>client secret</strong> and store it, along with the <strong>application ID</strong> for future use.</p>

<p>Alright, got your AAD application registered? Let’s use that to authenticate.</p>

<pre><code class="language-PowerShell">$tenantId = 'powers-hell.com'
$clientId = 'e8984d96-a7b8-4ee0-a2ef-e42ddca2f3a2'
$clientSecret = 'superSecretKey'

$reqestBody = @{
    resource      = 'https://graph.microsoft.com'
    client_id     = $clientId
    client_secret = $clientSecret
    grant_type    = "client_credentials"
    scope         = "openid"
}

$authParams = @{
    Method  = 'Post'
    Uri     = "https://login.microsoftonline.com/$tenantId/oauth2/token"
    Body    = $requestBody
}
$auth = Invoke-RestMethod @authParams
</code></pre>

<blockquote>
  <p>NOTE: If you just want to play around with this example but don’t want to build out an AAD app registration just to try stuff out, feel free to use the “well known” intune AAD application. Just know it can only be used with interactive authentication.<br />
<a href="% post_url 2021-07-18-authenticating-to-microsoft-graph-with-powershell-(2021) %">Read more about Graph authentication here.</a></p>
</blockquote>

<h2 id="finding-the-trusted-certificate-profiles">Finding the trusted certificate profiles</h2>

<p>Now that we have our authentication sorted out, let’s query Graph for those trusted certificate policies.</p>

<pre><code class="language-PowerShell">$authorizationHeader = @{
    Authorization = "Bearer $($auth.accessToken)"
}

$requestBody = @{
    Method      = 'Get'
    Uri         = 'https://graph.microsoft.com/beta/deviceManagement/deviceConfigurations'
    Headers     = $authorizationHeader
    ContentType = 'Application/Json'
}
$response = Invoke-RestMethod @requestBody
$foundCertificates = $response.value | Where-Object { $_.'@odata.type' -like "#microsoft.graph.*TrustedRootCertificate" }
$foundCertificates
</code></pre>

<p>What we are doing above is collecting all of the <strong>device configuration</strong> policies and removing all policies that do NOT adhere to our fuzzy filter of <strong>microsoft.graph.*TrustedRootCertificate</strong>. <br />
This should allow us to capture ALL possible certificate policies regardless of operating system.</p>

<p><a href="/assets/images/2021/12/foundCertificates.gif" title="Found Certificates"><img src="/assets/images/2021/12/foundCertificates.gif" alt="Found Certificates" /> </a></p>

<h2 id="decrypting-the-certificate-content">Decrypting the certificate content</h2>

<p>Now that we have our <strong>trusted certificate</strong> policies, let’s decrypt the certifate content and start analyzing it.</p>

<p>Assuming we get a few results from the above example and we just wanted to look at the first one..</p>

<pre><code class="language-PowerShell">$trustedRootCertificate = $foundCertificates[0]
$decryptedRootCertificate = [System.Text.Encoding]::ASCII.GetString([System.Convert]::FromBase64String($trustedRootCertificate.trustedRootCertificate))
</code></pre>
<p><a href="/assets/images/2021/12/foundCertificatesDecrypted.gif" title="Decrypted Certificates"><img src="/assets/images/2021/12/foundCertificatesDecrypted.gif" alt="Decrypted Certificates" /> </a></p>

<h2 id="extracting-the-expiration-metadata">Extracting the expiration metadata</h2>

<p>Now that we have the decrypted <strong>base 64</strong> encoded certificate, we can convert the content back to a <em>real certificate</em>..</p>

<pre><code class="language-PowerShell">$formattedCertContent = ($decryptedRootCertificate -replace "-----BEGIN CERTIFICATE-----|-----END CERTIFICATE-----", "").Trim()
$decryptedCertificate = [System.Security.Cryptography.X509Certificates.X509Certificate2]([System.Convert]::FromBase64String($formattedCertContent))
</code></pre>

<p>As you should be able to see from the above code, we are simply removing the bounding strings from the base64 string and converting the resultant encrypted string back into the .Net certificate class.</p>

<p>Once we have that, we should be able to step through the metadata and find the expiry date data we were originally after..</p>

<p><a href="/assets/images/2021/12/foundExpiryDate.gif" title="Found the expiry date!!"><img src="/assets/images/2021/12/foundExpiryDate.gif" alt="Found the expiry date!!" /></a></p>

<h2 id="base64-vs-der">Base64 vs DER</h2>

<p>“But wait!” I hear you scream. “What if my certificates weren’t exported as Base64 from my CA?!”.</p>

<p>Firstly, congratulations on being difficult.<br />
Secondly, of course there’s a way to handle that. Let’s look at that now.</p>

<p>I’ve intentionally created a second certificate policy that uses a DER encrypted certificate, so let’s decode that using the same code as above and see what we get back..</p>

<p><a href="/assets/images/2021/12/DerEncoded.gif" title="DER encoded certificate data.."><img src="/assets/images/2021/12/DerEncoded.gif" alt="DER encoded certificate data.." /></a></p>

<p>Gross. That isn’t looking too great is it..</p>

<p>Well, the good news is that even though it doesn’t look as nice as our base64 encoded example, it’s just as easy to build a certificate from!</p>

<pre><code class="language-PowerShell">[byte[]]$decryptedDerCert = [System.Convert]::FromBase64String($trustedRootCertificate.trustedRootCertificate)
$decryptedCertificate = [System.Security.Cryptography.X509Certificates.X509Certificate2]($decryptedDerCert)
</code></pre>

<p><a href="/assets/images/2021/12/DerDecoded.gif" title="Decoded DER certificate"><img src="/assets/images/2021/12/DerDecoded.gif" alt="Decoded DER certificate" /></a></p>

<h2 id="well-what-now">Well, what now?</h2>

<p>Do something with it!</p>

<p>Now that we know that we can expose the certificate metadata from the Intune configuration profile, it means we can use it to trigger certain actions..</p>

<p>Take the following code as an example..</p>

<pre><code class="language-PowerShell">#region config
$config = @{
    tenantId     = "powers-hell.com"
    appId        = "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"
    clientSecret = "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"
    dayThreshold = 7
}
#endregion

#region functions
function Get-AuthHeader {
    [cmdletbinding()]
    param (
        [parameter(Mandatory = $true)]
        [string]$TenantId,
        [parameter(Mandatory = $true)]
        [string]$ApplicationId,
        [parameter(Mandatory = $true)]
        [string]$ClientSecret
    )
    $reqestBody = @{
        resource      = 'https://graph.microsoft.com'
        client_id     = $ApplicationId
        client_secret = $clientSecret
        grant_type    = "client_credentials"
        scope         = "openid"
    }

    $authParams = @{
        Method = 'Post'
        Uri = "https://login.microsoftonline.com/$TenantId/oauth2/token"
        Body = $requestBody
    }
    $auth = Invoke-RestMethod @authParams
    $authorizationHeader = @{
        Authorization = "Bearer $($auth.accessToken)"
    }
    return $authorizationHeader
}

function Get-TrustedCertificatesFromIntune {
    [cmdletbinding()]
    param (
        [parameter(Mandatory = $true)]
        [hashtable]$AuthHeader
    )

    try {
        #region Query Graph
        $baseUri = 'https://graph.microsoft.com/beta/deviceManagement/deviceConfigurations'
        $graphParams = @{
            Method      = 'Get'
            Uri         = $baseUri
            Headers     = $AuthHeader
            ContentType = 'Application/Json'
        }
        $result = Invoke-RestMethod @graphParams
        $resultValue = $result.value.Count -gt 0 ? $result.value : $null
        #endregion
        #region Format the results
        $foundCertificates = $resultValue | Where-Object { $_.'@odata.type' -like "#microsoft.graph.*TrustedRootCertificate" }
        if ($foundCertificates.Count -gt 0) {
            Write-Verbose "$($foundCertificates.Count) Trusted certificates found"
            return $foundCertificates
        }
        #endregion
    }
    catch {
        Write-Warning $_.Exception.Message
    }
}

function Get-CertificateDataFromTrustedCertificatePolicy {
    [cmdletbinding()]
    param (
        [parameter(Mandatory = $True, ValueFromPipeline)]
        [PSCustomObject]$TrustedRootCertificate
    )
    try {
        $decryptedTRC = [System.Text.Encoding]::ASCII.GetString([System.Convert]::FromBase64String($TrustedRootCertificate.trustedRootCertificate))
        if ($decryptedTRC -match "-----BEGIN CERTIFICATE-----") {
            #region base64 encoded certificate detected
            Write-Verbose "Base64 encoded certificate detected.."
            $formattedCertContent = ($decryptedTRC -replace "-----BEGIN CERTIFICATE-----|-----END CERTIFICATE-----", "").Trim()
            $decryptedCertificate = [System.Security.Cryptography.X509Certificates.X509Certificate2]([System.Convert]::FromBase64String($formattedCertContent))
            return $decryptedCertificate
            #endregion
        }
        else {
            #region der encoded certificate detected
            Write-Verbose "Der encoded certificate detected.."
            [byte[]]$decryptedDerTRC = [System.Convert]::FromBase64String($TrustedRootCertificate.trustedRootCertificate)
            $decryptedCertificate = [System.Security.Cryptography.X509Certificates.X509Certificate2]($decryptedDerTRC)
            return $decryptedCertificate
            #endregion
        }
    }
    catch {
        Write-Warning $_.Exception.Message
    }
}
#endregion

#region auth
$authHeader = Get-AuthHeader -TenantId $config.tenantId -ApplicationId $config.appId -ClientSecret $config.clientSecret
#endregion

#region grab certificate profiles
$certificateProfiles = Get-TrustedCertificatesFromIntune -AuthHeader $authHeader
#endregion

#region grab certicate metadata
$certificates = foreach ($cert in $certificateProfiles) {
    Get-CertificateDataFromTrustedCertificatePolicy -TrustedRootCertificate $cert
}
#endregion

#region grab certicate metadata and send alerts if certificate expires within set threshold
$Expiringcertificates = foreach ($cert in $certificateProfiles) {
    $certData = Get-CertificateDataFromTrustedCertificatePolicy -TrustedRootCertificate $cert
    $daysRemaining = [math]::Round((($certData.NotAfter) - ([DateTime]::Now)).TotalDays)
    if ($daysRemaining -lt $config.dayThreshold) {
        Write-Host "$($cert.displayName) expires in $daysRemaining days ⚠️⚠️⚠️"
        $certData
    }
}
#endregion
</code></pre>
<p>Populating the <code class="language-plaintext highlighter-rouge">$config</code> variable with your app credentials and setting the date threshold will analyze any <strong>trusted certificate</strong> policies and advise you if any are due to expire.</p>

<p><a href="/assets/images/2021/12/get-certificateexpiry.gif" title="Uhoh... certificates are about to expire"><img src="/assets/images/2021/12/get-certificateexpiry.gif" alt="Uhoh... certificates are about to expire" /></a></p>

<p>Now that you have a working solution to monitor for expiring certificates, why don’t you try building it into an Azure Function that runs on a daily schedule? How about sending the results of the script out to a Teams webhook to notify your team in a more dynamic way?</p>

<p>Isn’t automation cool?!</p>

<p>As always, all code shown in this article is available on <a href="https://github.com/tabs-not-spaces/CodeDump/tree/master/CertificateExpiration">GitHub</a></p>

<p>— Ben</p>]]></content><author><name>Ben</name></author><category term="PowerShell" /><category term="Azure" /><category term="Automation" /><category term="Azure Functions" /><category term="Intune" /><category term="PowerShell" /><category term="Azure" /><category term="Automation" /><category term="Azure Functions" /><category term="Intune" /><summary type="html"><![CDATA[How do you remind yourself to renew your CA root certificates / subordinate certificates? Do you set a calendar reminder? Did the person who set those reminders up forget to share them with the team and now is on holidays? Fear not, for I have holiday gift for you - using nothing but PowerShell, we can interrogate our trusted certificate policies and, as if by magic, send out alerts when the attached certificates are about to expire!]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://powers-hell.com/assets/images/2021/12/get-certificateexpiry.gif" /><media:content medium="image" url="https://powers-hell.com/assets/images/2021/12/get-certificateexpiry.gif" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Authenticate to Graph directly from PowerBI!</title><link href="https://powers-hell.com/2021/08/15/authenticate-to-graph-directly-from-powerbi/" rel="alternate" type="text/html" title="Authenticate to Graph directly from PowerBI!" /><published>2021-08-15T08:38:00+00:00</published><updated>2021-08-15T08:38:00+00:00</updated><id>https://powers-hell.com/2021/08/15/authenticate-to-graph-directly-from-powerbi</id><content type="html" xml:base="https://powers-hell.com/2021/08/15/authenticate-to-graph-directly-from-powerbi/"><![CDATA[<p>Recently, one of my colleagues sent me a really cool Intune application patching report that they were working on and I wanted to see if I could make the data collection more automated / dynamic. Now, It’s been a LONG time since I’ve dipped my toes into the headache that is PowerBI, but once I see a challenge, it’s difficult for me to leave it alone…</p>

<!--more-->

<p><a href="/2018/05/15/working-with-graphapi-powerbi-the-easy-way/">I’ve actually written about this before</a> - back in 2018 I ran into the exact same problem - how do you authenticate to Graph to pull back data using a custom AAD application when PowerBI doesn’t allow you to specifically define your authentication parameters?</p>

<p>At the time, I wrote about building a “middleware” solution that involved an Azure function application that handled the authentication as well as the Graph queries and simply returned the results back to the report. That solution still works just fine, but if we want people that aren’t nerds like me to actually use the reports, we ideally want a solution that has the authentication piece baked directly into the file.</p>

<p>Well, it turns out all the pieces I need to have that work have been staring me in the face for years. Yes there is still no native way to define your authentication method, but with a little bit of work, you 110% can authenticate to Graph using any AAD application that you want.</p>

<p>The secret of it all turns out to be quite simple. <a href="/2018/08/17/authenticate-to-microsoft-graph-in-powershell-in-two-lines-of-code/">As I wrote about in my article about authenticating to Graph</a>, if you know how the authentication requests are built, you can actually build the requests <strong>WITHOUT</strong> the libraries. Understanding that, we then need to simply build a way to have end users input their authentication parameters into a function that builds the authentication request for you.</p>

<p>Luckily in PowerBI we can do this very easily (Sorry to all PowerBI nerds out there who already know this). All we need to do is prepare a few parameters and write a custom function query that will act as our tooling.</p>

<p>Let’s start by creating a new empty report. We want to dive right into the guts of PowerBI, so select <strong>Transform data</strong> to enter the <strong>Power Query Editor</strong>.</p>

<p>Now let’s create the necessary parameters we want the end user to populate. Right click on the queries pane and select <strong>New Parameter</strong>. We will then build out the following parameters. Feel free to put them into groups - It just looks so much neater.</p>

<table>
  <thead>
    <tr>
      <th>Parameter Name</th>
      <th>Type</th>
      <th>Current Value</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Tenant Id</td>
      <td>Text</td>
      <td>Your Tenant Id / Url</td>
    </tr>
    <tr>
      <td>Client Id</td>
      <td>Text</td>
      <td>Your AAD application Id</td>
    </tr>
    <tr>
      <td>Client Secret</td>
      <td>Text</td>
      <td>Your AAD appplication client secret</td>
    </tr>
    <tr>
      <td>Resource</td>
      <td>Text</td>
      <td>https://graph.microsoft.com</td>
    </tr>
  </tbody>
</table>

<p><a href="/assets/images/2021/08/PowerBI-Parameters.gif" title="Building Parameters"><img src="/assets/images/2021/08/PowerBI-Parameters.gif" alt="Building Parameters" /></a></p>

<p>Alright, now that we have our parameters, let’s build our first function. Select <strong>New Source &gt; Blank Query</strong> and then select <strong>Advanced Editor</strong> to bring up the editor. The code we will place into this new blank query is below.</p>

<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="err">_</span><span class="n">tenantId</span><span class="w"> </span><span class="n">as</span><span class="w"> </span><span class="n">text</span><span class="p">,</span><span class="w"> </span><span class="err">_</span><span class="n">clientId</span><span class="w"> </span><span class="n">as</span><span class="w"> </span><span class="n">text</span><span class="p">,</span><span class="w"> </span><span class="err">_</span><span class="n">clientSecret</span><span class="w"> </span><span class="n">as</span><span class="w"> </span><span class="n">text</span><span class="p">,</span><span class="w"> </span><span class="err">_</span><span class="n">resource</span><span class="w"> </span><span class="n">as</span><span class="w"> </span><span class="n">text</span><span class="p">,</span><span class="w"> </span><span class="err">_</span><span class="n">grantType</span><span class="w"> </span><span class="n">as</span><span class="w"> </span><span class="n">text</span><span class="p">,</span><span class="w"> </span><span class="err">_</span><span class="n">scope</span><span class="w"> </span><span class="n">as</span><span class="w"> </span><span class="n">text</span><span class="p">)</span><span class="w"> </span><span class="n">as</span><span class="w"> </span><span class="n">text</span><span class="w"> </span><span class="o">=&gt;</span><span class="w">
</span><span class="n">let</span><span class="w">
    </span><span class="n">Url</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"https://login.microsoftonline.com/"</span><span class="o">&amp;</span><span class="err">_</span><span class="n">tenantId</span><span class="o">&amp;</span><span class="s2">"/oauth2/token"</span><span class="p">,</span><span class="w">
    </span><span class="n">Body</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"resource="</span><span class="o">&amp;</span><span class="err">_</span><span class="n">resource</span><span class="o">&amp;</span><span class="s2">"&amp;client_id="</span><span class="o">&amp;</span><span class="err">_</span><span class="n">clientId</span><span class="o">&amp;</span><span class="s2">"&amp;grant_type="</span><span class="o">&amp;</span><span class="err">_</span><span class="n">grantType</span><span class="o">&amp;</span><span class="s2">"&amp;scope="</span><span class="o">&amp;</span><span class="err">_</span><span class="n">scope</span><span class="o">&amp;</span><span class="s2">"&amp;client_secret="</span><span class="o">&amp;</span><span class="err">_</span><span class="n">clientSecret</span><span class="p">,</span><span class="w">
    </span><span class="n">Options</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="w">
        </span><span class="n">Content</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Text.ToBinary</span><span class="p">(</span><span class="n">Body</span><span class="p">)</span><span class="w">
    </span><span class="p">],</span><span class="w">
    </span><span class="n">Response</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Web.Contents</span><span class="p">(</span><span class="n">Url</span><span class="p">,</span><span class="n">Options</span><span class="p">),</span><span class="w">
    </span><span class="n">ParsedJson</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Json.Document</span><span class="p">(</span><span class="n">Response</span><span class="p">),</span><span class="w">
    </span><span class="n">ConvertedToken</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"Bearer "</span><span class="o">&amp;</span><span class="n">ParsedJson</span><span class="p">[</span><span class="n">access_token</span><span class="p">]</span><span class="w">
</span><span class="k">in</span><span class="w">
    </span><span class="n">ConvertedToken</span><span class="w">
</span></code></pre></div></div>

<p>What we have above is actually quite simple:</p>
<ul>
  <li>The first line defines the parameters and their types that will be accepted into our function.</li>
  <li>The rest of the code in the <strong>let</strong> segment simply builds out the request URL, request body &amp; posts the request.</li>
  <li>Finally, we pull out the <strong>access token</strong> from the response and prepend “Bearer” to it, so we can use it for any future queries.</li>
</ul>

<p>Now that we have our reusable function to authenticate, give the query a name (I’ve called mine “Get-AuthenticationHeader”), and let’s create <strong>another</strong> blank query and fill the advanced editor with the following code..</p>

<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="err">_</span><span class="n">graphURL</span><span class="w"> </span><span class="n">as</span><span class="w"> </span><span class="n">text</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w">
</span><span class="n">let</span><span class="w">
    </span><span class="n">AuthHeader</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="c1">#"Get-AuthenticationHeader"(#"Tenant Id", #"Client Id", #"Client Secret", Resource, "client_credentials", "openid"),</span><span class="w">
    </span><span class="n">Options</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="w">
        </span><span class="n">Headers</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="w">
            </span><span class="n">Authorization</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">AuthHeader</span><span class="p">,</span><span class="w">
            </span><span class="c1">#"Content-Type" = "Application/Json"</span><span class="w">
        </span><span class="p">]</span><span class="w">
    </span><span class="p">],</span><span class="w">
    </span><span class="n">WebRequestContent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Web.Contents</span><span class="p">(</span><span class="err">_</span><span class="n">graphURL</span><span class="p">,</span><span class="n">Options</span><span class="p">),</span><span class="w">
    </span><span class="n">JsonContent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Json.Document</span><span class="p">(</span><span class="n">WebRequestContent</span><span class="p">),</span><span class="w">
    </span><span class="n">ParsedResults</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">JsonContent</span><span class="p">[</span><span class="n">value</span><span class="p">],</span><span class="w">
    </span><span class="n">Converted</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Table.FromList</span><span class="p">(</span><span class="n">ParsedResults</span><span class="p">,</span><span class="w"> </span><span class="n">Splitter.SplitByNothing</span><span class="p">(),</span><span class="w"> </span><span class="n">null</span><span class="p">,</span><span class="w"> </span><span class="n">null</span><span class="p">,</span><span class="w"> </span><span class="n">ExtraValues.Error</span><span class="p">),</span><span class="w">
    </span><span class="n">Expanded</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Table.ExpandRecordColumn</span><span class="p">(</span><span class="n">Converted</span><span class="p">,</span><span class="s2">"Column1"</span><span class="p">,</span><span class="w">
                    </span><span class="n">Record.FieldNames</span><span class="p">(</span><span class="n">Converted</span><span class="p">[</span><span class="n">Column1</span><span class="p">]{</span><span class="m">0</span><span class="p">}),</span><span class="w">
                    </span><span class="n">Record.FieldNames</span><span class="p">(</span><span class="n">Converted</span><span class="p">[</span><span class="n">Column1</span><span class="p">]{</span><span class="m">0</span><span class="p">}))</span><span class="w">
</span><span class="k">in</span><span class="w">
    </span><span class="n">Expanded</span><span class="w">
</span></code></pre></div></div>

<p>As with our authentication function, give this one a name (I’ve called mine “Invoke-GraphRequest”).</p>

<p>What’s cool about the above function is it calls the first function for us, so that we only need to interface with the second function and provide a single parameter, which is the URL of the Graph endpoint we want to pull back into PowerBI.</p>

<p>There’s a bit more going on after we pull back the data, specifically we convert the resultant data from a list of records to a table of data using the property names as the column names… Exciting stuff, right?</p>

<p>OK - we now have two helper functions, let’s actually start pulling some data in. Let’s click on the <strong>Invoke-GraphRequest</strong> function and we should see a nice interface asking us to enter a parameter to insert into the function. I want to look at all the apps in my tenant, so I’m going to query <code class="language-plaintext highlighter-rouge">https://graph.microsoft.com/beta/deviceAppManagement/mobileApps</code> so I’ll put that address into the function and press <strong>invoke</strong>.</p>

<p><a href="/assets/images/2021/08/PowerBI-FunctionInvoke.gif" title="Invoke-GraphRequest"><img src="/assets/images/2021/08/PowerBI-FunctionInvoke.gif" alt="Invoke-GraphRequest" /></a></p>

<p>FANCY!!</p>

<p>Looking at the <em>code behind</em> that this invoked function generates shows us how simple things are now that we have abstracted out the process into two unique functions..</p>

<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">let</span><span class="w">
    </span><span class="n">Source</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="c1">#"Invoke-GraphRequest"("https://graph.microsoft.com/beta/deviceAppManagement/mobileApps")</span><span class="w">
</span><span class="k">in</span><span class="w">
    </span><span class="n">Source</span><span class="w">
</span></code></pre></div></div>

<p>As you can see, we have a single request which is just invoking the second function we created with the single Graph URL as a parameter input.</p>

<p>Now you have a simple framework to collect as many endpoint datasets as you want - just find what the endpoint URL is and build a query.</p>

<p>There is a litte more that should be done before this is used in production - specifically, the second function should support paging so that it can collect all data available incase it is broken out into pages of data, but that should not be too hard to accomplish. Once I’ve written that I’ll come back and edit this post. If anyone else feels like figuring it out, feel free to leave the code in a comment below.</p>

<p>But now the cool thing is, if we save this PowerBI report as a template and send it to someone, they will open it &amp; it will ask them to fill out the parameters, and as if by magic, will populate out the reports we generated!</p>

<p><a href="/assets/images/2021/08/PowerBI-Template.gif" title="Open Template And Build Report"><img src="/assets/images/2021/08/PowerBI-Template.gif" alt="Open Template And Build Report" /></a></p>

<p>I personally can’t wait to close PowerBI and never open it again for another 5 years!</p>

<p>Love this? Hate it? Have a better solution? Let me know on <a href="https://twitter.com/powers_hell">twitter</a> or leave a comment below.</p>

<p>For those who don’t want to build a template from scratch - don’t worry. <a href="https://github.com/tabs-not-spaces/CodeDump/tree/master/PowerBI-GraphAuthentication">I’ve put the template built from this post on GitHub.</a></p>

<p>— Ben</p>]]></content><author><name>Ben</name></author><category term="PowerBI" /><category term="Graph" /><category term="Intune" /><category term="Reporting" /><category term="Automation" /><category term="PowerBI" /><category term="Graph" /><category term="Intune" /><category term="Reporting" /><category term="Automation" /><summary type="html"><![CDATA[Recently, one of my colleagues sent me a really cool Intune application patching report that they were working on and I wanted to see if I could make the data collection more automated / dynamic. Now, It’s been a LONG time since I’ve dipped my toes into the headache that is PowerBI, but once I see a challenge, it’s difficult for me to leave it alone…]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://powers-hell.com/assets/images/2021/08/PowerBI-FunctionInvoke.gif" /><media:content medium="image" url="https://powers-hell.com/assets/images/2021/08/PowerBI-FunctionInvoke.gif" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Build a Jekyll development environment with VS Code &amp;amp; Remote Containers</title><link href="https://powers-hell.com/2021/07/25/build-a-jekyll-development-environment-with-vs-code-remote-containers/" rel="alternate" type="text/html" title="Build a Jekyll development environment with VS Code &amp;amp; Remote Containers" /><published>2021-07-25T08:12:00+00:00</published><updated>2021-07-25T08:12:00+00:00</updated><id>https://powers-hell.com/2021/07/25/build-a-jekyll-development-environment-with-vs-code-remote-containers</id><content type="html" xml:base="https://powers-hell.com/2021/07/25/build-a-jekyll-development-environment-with-vs-code-remote-containers/"><![CDATA[<p>So you want to build a site, host it on Github (for free) and don’t know where to start? Here’s how I did it!</p>

<!--more-->

<p>Since moving this site away from WordPress and rebuilding the site from the ground up using <a href="https://jekyllrb.com/">Jekyll</a>, <a href="https://tailwindcss.com/">Tailwind CSS</a> &amp; <a href="https://draculatheme.com/ui">Dracula UI</a>, I’ve had lots of questions about <strong>how</strong> others could do the same. Now, this isn’t obviously what I normally talk about (PowerShell / Intune), I think the concepts I usually talk about - automation, making tools work better for you, having fun learning new skills are transferrable to this. Plus… It’s <strong>my</strong> site!</p>

<p>So what I’m going to cover is how to leverage a <strong>very basic</strong> github template and convert it into a solution that with a click of your mouse will provision a Docker container that has everything you need to develop a Jekyll static web app.</p>

<p>What I will <strong>NOT</strong> be talking about is how to <em>build</em> a jekyll website, or how to write HTML / CSS / Javascript. This is an introductory guide to using the <a href="https://code.visualstudio.com/blogs/2021/06/10/remote-repositories">remote repository</a> extension of VS Code to help you get started with Jekyll - not a website development lesson.</p>

<p>With that out of the way, let’s get into the fun!</p>

<h2 id="pre-requirements">Pre-requirements</h2>

<p>Before you start, please make sure you have the following installed on your device.</p>

<ul>
  <li><a href="https://docs.microsoft.com/en-us/windows/wsl/install-win10">Windows Subsystem for Linux (WSL2)</a></li>
  <li><a href="https://www.docker.com/products/docker-desktop">Docker Desktop</a></li>
  <li><a href="https://code.visualstudio.com/download">Visual Studio Code</a></li>
  <li>Visual Studio Code Extensions:
    <ul>
      <li><a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.vscode-remote-extensionpack">Remote Development</a></li>
      <li><a href="https://marketplace.visualstudio.com/items?itemName=GitHub.remotehub">Remote Repositories</a></li>
    </ul>
  </li>
</ul>

<p>Once the above has been installed we can begin.</p>

<h2 id="create-a-repository-from-a-jekyll-starter-template">Create a repository from a Jekyll starter template.</h2>

<p>As mentioned, this is just how I’ve set up my site, it’s not the <strong>only</strong> way to do it, but it sure is easy.</p>

<p>Let’s begin by generating a project repository from the <a href="https://github.com/mloberg/jekyll-starter/generate">jekyll-starter</a> repo.</p>

<p><a href="/assets/images/2021/07/generatefromtemplate.gif" title="Generate repo from template"><img src="/assets/images/2021/07/generatefromtemplate.gif" alt="Generate repo from template" /></a></p>

<p>That was easy, wasn’t it?!</p>

<h2 id="prepare-the-repository-for-remote-container-support">Prepare the repository for remote container support.</h2>

<p>Now we want to make it so we can open this new repository as a <em>remote container</em> in VS Code. The easiest way to do that is to put a link in the readme of the project. Scroll down to the readme.md and hit the edit button. We are going to add the following code to the top of the file.</p>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="nv">![Open in Visual Studio Code</span><span class="p">](</span><span class="sx">https://img.shields.io/badge/Open%20in-Visal%20Studio%20Code-blue?style=for-the-badge&amp;logo=visualstudiocode</span><span class="p">)</span>](https://open.vscode.dev/your-github-username/your-repository-name)
</code></pre></div></div>

<p>Copy the above code and edit the URL to reflect your GitHub account name and the name of the repository you created from the previous step. As an example, the URL I would put in for my example would be <code class="language-plaintext highlighter-rouge">https://open.vscode.dev/tabs-not-spaces/Heaps-Cool-Website</code>.</p>

<p>Commit the changes you’ve made and you should now have a handy button that we will use in the next step.</p>

<p><a href="/assets/images/2021/07/create-open-button.gif" title="Create &quot;Open in VSCode&quot; button"><img src="/assets/images/2021/07/create-open-button.gif" alt="Create &quot;Open in VSCode&quot; button" /></a></p>

<h2 id="clone-repo-in-container-volume">Clone repo in container volume</h2>

<p>Now that we have our new handy dandy button added to our readme - let’s click it.</p>

<p>We should be greeted with a jump-off page with two options:</p>

<ul>
  <li>Open with Remote Repositories</li>
  <li>Clone repo in container volume</li>
</ul>

<p>By the name of this section, you should know what’s about to happen - click on the <strong>Clone repo in container volume</strong> button and accept any prompts that appear.</p>

<p><a href="/assets/images/2021/07/open-remote-container.gif" title="Open repo in container volume"><img src="/assets/images/2021/07/open-remote-container.gif" alt="Open repo in container volume" /></a></p>

<p>Because we have not configured our <strong>dev container</strong> in the repository, we are now going to be asked what exactly our development environment will look like..</p>

<h2 id="add-development-container-configuration-files">Add development container configuration files</h2>

<p>As shown in the image above, we should now have a docker instance loaded that is asking us how we want to set up our environment. Luckily, Microsoft has created a bunch of great reference development container templates we can utilize as a jump off point.</p>

<p>Click on <strong>Show All Definitions…</strong> and search for <strong>Ruby</strong>.</p>

<p>From here we are going to select the latest release of <strong>Ruby (3.0)</strong> and we are going to make sure to include <strong>Node.js</strong> to our container.</p>

<p>Our Docker container will now build based off our configuration and you should be left with an instance of VS Code remotely connected to a Docker container housing your site &amp; all required software to develop the site!</p>

<p><a href="/assets/images/2021/07/dev-container-config-files.gif" title="Add development container configuration files"><img src="/assets/images/2021/07/dev-container-config-files.gif" alt="Add development container configuration files" /></a></p>

<h2 id="customize-development-environment">Customize development environment</h2>

<p>At this stage everything we have done has been <strong>out of the box</strong> configuration. We now need to make a few changes to customize it to work the way we want.</p>

<p>First, we need to add some Jekyll plugins to the project to make sure we can build the site.</p>

<p>Open up the <strong>gemfile</strong> file and let’s add the <strong>webrick</strong> plugin to our config. The file should look like this..</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">source</span> <span class="s2">"https://rubygems.org"</span>

<span class="n">gem</span> <span class="s2">"jekyll"</span><span class="p">,</span> <span class="s2">"~&gt; 4.1"</span>
<span class="n">gem</span> <span class="s2">"webrick"</span>

<span class="n">group</span> <span class="ss">:jekyll_plugins</span> <span class="k">do</span>
<span class="c1">#   gem "jekyll-feed"</span>
  <span class="n">gem</span> <span class="s2">"jekyll-seo-tag"</span>
  <span class="n">gem</span> <span class="s2">"jekyll-sitemap"</span>
<span class="c1">#   gem "jekyll-archives"</span>
<span class="c1">#   gem "jekyll-redirect-from"</span>
  <span class="n">gem</span> <span class="s2">"jekyll-compose"</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Next, open the <strong>webpack.config.js</strong> file and remove the <strong>test.config</strong> line. It should end up looking like this..</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">Encore</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">@symfony/webpack-encore</span><span class="dl">'</span><span class="p">);</span>

<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">Encore</span><span class="p">.</span><span class="nx">isRuntimeEnvironmentConfigured</span><span class="p">())</span> <span class="p">{</span>
  <span class="nx">Encore</span><span class="p">.</span><span class="nx">configureRuntimeEnvironment</span><span class="p">(</span><span class="nx">process</span><span class="p">.</span><span class="nx">env</span><span class="p">.</span><span class="nx">NODE_ENV</span> <span class="o">||</span> <span class="dl">'</span><span class="s1">dev</span><span class="dl">'</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">process</span><span class="p">.</span><span class="nx">env</span><span class="p">.</span><span class="nx">NODE_ENV</span> <span class="o">=</span> <span class="nx">Encore</span><span class="p">.</span><span class="nx">isProduction</span><span class="p">()</span> <span class="p">?</span> <span class="dl">'</span><span class="s1">production</span><span class="dl">'</span> <span class="p">:</span> <span class="dl">'</span><span class="s1">dev</span><span class="dl">'</span><span class="p">;</span>

<span class="nx">Encore</span>
  <span class="p">.</span><span class="nx">setOutputPath</span><span class="p">(</span><span class="dl">'</span><span class="s1">assets/</span><span class="dl">'</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">setPublicPath</span><span class="p">(</span><span class="dl">'</span><span class="s1">/assets</span><span class="dl">'</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">addStyleEntry</span><span class="p">(</span><span class="dl">'</span><span class="s1">css/app</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">./_assets/css/app.css</span><span class="dl">'</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">addEntry</span><span class="p">(</span><span class="dl">'</span><span class="s1">js/app</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">./_assets/js/app.js</span><span class="dl">'</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">enablePostCssLoader</span><span class="p">()</span>
  <span class="p">.</span><span class="nx">disableSingleRuntimeChunk</span><span class="p">()</span>
  <span class="p">.</span><span class="nx">enableSourceMaps</span><span class="p">(</span><span class="o">!</span><span class="nx">Encore</span><span class="p">.</span><span class="nx">isProduction</span><span class="p">());</span>

<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="nx">Encore</span><span class="p">.</span><span class="nx">getWebpackConfig</span><span class="p">();</span>

</code></pre></div></div>

<p>Next, let’s customize some of the basic metadata of our new site. Open the <strong>_config.yml</strong> file and set up all of the properties to reflect the project. Here’s mine as an example..</p>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>title: My Heaps Cool Website
description: This is "HEAPS COOL"
permalink: /:slugified_categories/:title/

date_format: "%b %-d, %Y"

exclude:
<span class="p">  -</span> "package<span class="err">*</span>.json"
<span class="p">  -</span> "<span class="err">*</span>.config.js"
<span class="p">  -</span> netlify.toml
<span class="p">  -</span> README.md
<span class="p">  -</span> LICENSE
<span class="p">  -</span> Makefile
</code></pre></div></div>

<p>Finally, let’s build a simple VS Code task to help us start our site for live development.</p>

<ul>
  <li>Open up the command palette (Ctrl+Shift+P) and search for <strong>Configure Task</strong></li>
  <li>Scroll to the bottom and select <strong>Create tasks.json file from template</strong></li>
  <li>Select <strong>others</strong> to build an empty tasks template file.</li>
</ul>

<p>Now let’s add the below code to the .vscode/tasks.json file that has been created in our repository.</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
    </span><span class="nl">"label"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Jekyll: Build Dev"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"detail"</span><span class="p">:</span><span class="w"> </span><span class="s2">"bundle install &amp;&amp; npm install &amp;&amp; npm run dev &amp;&amp; npm start"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"shell"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"linux"</span><span class="p">:{</span><span class="w">
        </span><span class="nl">"command"</span><span class="p">:</span><span class="w"> </span><span class="s2">"bundle install &amp;&amp; npm install &amp;&amp; npm run dev &amp;&amp; npm start"</span><span class="w">
    </span><span class="p">},</span><span class="w">
    </span><span class="nl">"group"</span><span class="p">:{</span><span class="w">
        </span><span class="nl">"kind"</span><span class="p">:</span><span class="w"> </span><span class="s2">"build"</span><span class="p">,</span><span class="w">
        </span><span class="nl">"isDefault"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">
    </span><span class="p">},</span><span class="w">
    </span><span class="nl">"presentation"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="nl">"echo"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span><span class="w">
        </span><span class="nl">"reveal"</span><span class="p">:</span><span class="w"> </span><span class="s2">"always"</span><span class="p">,</span><span class="w">
        </span><span class="nl">"focus"</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w">
        </span><span class="nl">"panel"</span><span class="p">:</span><span class="w"> </span><span class="s2">"shared"</span><span class="p">,</span><span class="w">
        </span><span class="nl">"showReuseMessage"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span><span class="w">
        </span><span class="nl">"clear"</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="w">
    </span><span class="p">},</span><span class="w">
    </span><span class="nl">"problemMatcher"</span><span class="p">:[</span><span class="s2">"$eslint-stylish"</span><span class="p">,</span><span class="s2">"$jekyll-error-watch"</span><span class="p">,</span><span class="w"> </span><span class="s2">"$jekyll-warning-watch"</span><span class="p">]</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>
<p><a href="/assets/images/2021/07/vscode-tasks.gif" title="VS Code Tasks"><img src="/assets/images/2021/07/vscode-tasks.gif" alt="VS Code Tasks" /></a></p>

<p>Now that we have everything configured, the next step is to start the development environment and see if the site displays.</p>

<ul>
  <li>Open the command palette (Ctrl+Shift+P) and search for <strong>Run Task</strong></li>
  <li>Select the default option, which is the task we just built.</li>
</ul>

<p>The site will now build and generate a local web server that will host the site from within the development container. Once it is completed building, you will recieve an option to open the development server from within your browser or from within VS Code!</p>

<p><a href="/assets/images/2021/07/build-and-change.gif" title="Build and run"><img src="/assets/images/2021/07/build-and-change.gif" alt="Build and run" /></a></p>

<p>Now comes the fun part of building your site, designing the theme and of course, writing content!</p>

<h2 id="deploy-site-with-github-actions">Deploy site with GitHub Actions</h2>

<p>Now that you have the basic framework for a Jekyll development environment (and maybe written a post or two), you’ll want to configure some automation to publish the site to GitHub.</p>

<p>Thankfully, the template we built our project with comes with a GitHub Action Workflow that does most of what we need to prepare the site for GitHub.</p>

<p>So let’s commit and push the changes we’ve made to the project back to the repository and watch the workflow do some magic.</p>

<p><a href="/assets/images/2021/07/gh-action.gif" title="Commit and publish"><img src="/assets/images/2021/07/gh-action.gif" alt="Commit and publish" /></a></p>

<p>Once the action has completed, a new branch is created named <strong>gh-pages</strong>. This is where the processed static files are stored.</p>

<p>The last step of this process is to link that repository to GitHub pages.</p>

<p>Head over to Settings &gt; Pages and set the source to the <strong>gh-pages</strong> branch.</p>

<p>Now if you go to the URL shown on the screen, you should see your shiny new Jekyll site!</p>

<p><a href="/assets/images/2021/07/link-gh-page-to-gh-site.gif" title="Link site to GitHub Pages"><img src="/assets/images/2021/07/link-gh-page-to-gh-site.gif" alt="Link site to GitHub Pages" /></a></p>

<p>Thanks for getting this far - I know this isn’t my normal subject matter, but I’ve been having lots of fun learning and playing with Remote Repositories &amp; Docker and hopefully this helps someone who is just getting started.</p>

<p>— Ben</p>]]></content><author><name>Ben</name></author><category term="Jekyll" /><category term="Static Web App" /><category term="VS Code" /><category term="Remote Container" /><category term="Docker" /><category term="Jekyll" /><category term="Static Web App" /><category term="VS Code" /><category term="Remote Container" /><category term="Docker" /><summary type="html"><![CDATA[So you want to build a site, host it on Github (for free) and don’t know where to start? Here’s how I did it!]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://powers-hell.com/assets/images/2021/07/build-and-change.gif" /><media:content medium="image" url="https://powers-hell.com/assets/images/2021/07/build-and-change.gif" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Authenticating to Microsoft Graph with PowerShell - (2021)</title><link href="https://powers-hell.com/2021/07/18/authenticating-to-microsoft-graph-with-powershell-(2021)/" rel="alternate" type="text/html" title="Authenticating to Microsoft Graph with PowerShell - (2021)" /><published>2021-07-18T05:37:00+00:00</published><updated>2021-07-18T05:37:00+00:00</updated><id>https://powers-hell.com/2021/07/18/authenticating-to-microsoft-graph-with-powershell-(2021)</id><content type="html" xml:base="https://powers-hell.com/2021/07/18/authenticating-to-microsoft-graph-with-powershell-(2021)/"><![CDATA[<p>Talking about ways to authenticate to Graph is one of my least favourite subjects. After a while it gets a bit monotonous, but as with all technologies, things change..</p>

<!--more-->

<p>So I’ve decided to try something out - once a year, I’m going to write a revised guide to the BEST ways to authenticate using PowerShell (in my opinion) and make mention of any new notable advances within the space (if there are any!).</p>

<p>Alright, with the intro out of the way, let’s dive in.</p>

<h2 id="quick-primer">Quick Primer</h2>

<p><a href="https://docs.microsoft.com/en-us/graph/overview">Microsoft Graph</a>, for those living under a rock, is the underlying API that unifys Microsoft 365, Windows 10 &amp; Enterprise Mobility + Security, so that all we need to learn is a <strong>single REST API</strong> to give us programmatic access to read and interact with the data within those product ecosystems.</p>

<p>To work with Graph, the first and foremost thing we need to do is authenticate into the service. Using PowerShell makes this SIMPLE.</p>

<h2 id="how-do-i-authenticate">How do I authenticate?</h2>

<p>Authentication is surprisingly easy, once you understand the underlying concepts.</p>

<p>At a high level, all we are doing is providing some form of proof that we are allowed access to the Graph data in our Azure tenant. We do this using an authentication technology called <a href="https://oauth.net/2/">OAuth 2.0</a>. There are two primary methods of authentication:</p>

<ul>
  <li>Interactive, or delegated authentication. This allows us to authenticate to Graph utilizing our Azure AD account / password. This generally assumes an interactive experience, meaning you are probably running a script locally, or using a tool on your computer.</li>
  <li>Programmatic, or application authentication. This allows us to authenticate to Graph utilizing the credentials of an application registered in AAD. This allows us to securely authenticate to Graph without requiring user interaction, is not tied to a specific user account and access is controlled via the app registrations portal of AAD.</li>
</ul>

<p>Regardless of what method you choose to authenticate to Graph, the process is essentially the same and can actually be done very quickly / simply by just correctly forming and sending a HTTP request to the OAuth endpoint. <a href="/2018/08/17/authenticate-to-microsoft-graph-in-powershell-in-two-lines-of-code/">I’ve discussed this previously</a>, and not much has changed since that article. Below shows how to authenticate both Interactively &amp; Programmatically using nothing but PowerShell.</p>

<h3 id="interactive-authentication">Interactive authentication</h3>

<pre><code class="language-PowerShell">$tenantId = 'powers-hell.com'
$requestBody = @{
    resource   = 'https://graph.microsoft.com'
    client_id  = 'd1ddf0e4-d672-4dae-b554-9d5bdfd93547'
    grant_type = "password"
    username   = 'ben@powers-hell.com'
    scope      = "openid"
    password   = 'MySuperSecetPassword'
}
$auth = Invoke-RestMethod -Method post -Uri "https://login.microsoftonline.com/$tenantId/oauth2/token" -Body $requestBody
$auth
</code></pre>

<h3 id="programmatic-authentication">Programmatic authentication</h3>
<pre><code class="language-PowerShell">$tenantId = 'powers-hell.com'
$reqestBody = @{
    resource      = 'https://graph.microsoft.com'
    client_id     = 'd1ddf0e4-d672-4dae-b554-9d5bdfd93547'
    client_secret = $client_secret
    grant_type    = "client_credentials"
    scope         = "openid"
}
$auth = Invoke-RestMethod -Method post -Uri "https://login.microsoftonline.com/$tenantId/oauth2/token" -Body $requestBody
$auth
</code></pre>

<p>As you should be able to tell from both of those examples, they are almost identical, the only difference is the <strong>grant_type</strong> property, which simple tells the OAuth endpoint what to do with the credential payload we are sending along.</p>

<p>Both of these examples are very simple, but will work for most scenarios - with the key caveat being that you will not be able to handle MFA if your AAD tenant is configured to require it (for interactive authentication only.)</p>

<p>The good news is we can leverage existing authentication libraries provided by Microsoft to overcome these problems, as well as improving error handling and allowing for future changes to the authentication process.</p>

<h2 id="msal-adal-what-are-these-acronyms-and-what-do-i-do-with-them">MSAL? ADAL? What are these acronyms and what do I do with them?</h2>

<p>While we can manually build our authentication requests and send them to the OAuth endpoint, we should probably leverage the libraries created by Microsoft to make this experiences more reliable and easier.</p>

<p>To that end, Microsoft has built two authentication libraries over the years, the Active Directory Authentication Library (ADAL) and the Microsoft Authentication Library (MSAL).</p>

<p><span class="drac-text-yellow-pink drac-text-bold drac-text-lg">
!! DO NOT USE ADAL FOR AUTHENTICATION !!
</span></p>

<p>If the only thing you take away from the article is the following line, then I feel I have done my job. Microsoft has announced <a href="https://techcommunity.microsoft.com/t5/azure-active-directory-identity/update-your-applications-to-use-microsoft-authentication-library/ba-p/1257363"><strong>end of support timelines</strong> for ADAL</a>, and no further feature development will take place on the library.</p>

<p>Now that we have that out of the way, what does that mean? It means all we need to talk about is MSAL!</p>

<h2 id="authenticating-with-msalps">Authenticating with MSAL.PS</h2>

<p>By and far the EASIEST way to implement Graph authentication in your PowerShell solution is to leverage the excellent Module <a href="https://www.powershellgallery.com/packages/MSAL.PS/"><strong>MSAL.PS</strong></a>. <a href="/2020/06/28/managing-intune-with-graph-powershell-7-msal/">I’ve already spoken about how to use this module</a>, but to keep everything central, let’s go through it now.</p>

<p>First, let’s install the module</p>

<pre><code class="language-PowerShell">Install-Module MSAL.PS
</code></pre>

<p>Now let’s authenticate.</p>

<h3 id="interactive-authentication-1">Interactive authentication</h3>

<p>Assuming your AAD application has been setup correctly to work with MSAL (at minimum just make sure there’s a reply URL set to <strong>http://localhost</strong>) then we can use this code.</p>

<pre><code class="language-PowerShell">$authParams = @{
    ClientId    = 'd1ddf0e4-d672-4dae-b554-9d5bdfd93547'
    TenantId    = 'power-hell.com'
    Interactive = $true
}
$auth = Get-MsalToken @authParams
$auth
</code></pre>

<p>If it hasn’t - or you down own the AAD application and just need to use it interactively (specifically in PowerShell 7), then utilizing the DeviceCode auth flow will be required.</p>

<pre><code class="language-PowerShell">$authParams = @{
    ClientId    = 'd1ddf0e4-d672-4dae-b554-9d5bdfd93547'
    TenantId    = 'powers-hell.com'
    DeviceCode  = $true
}
$auth = Get-MsalToken @authParams
$auth
</code></pre>

<h3 id="programmatic-authentication-1">Programmatic authentication</h3>

<p>This one is simple!</p>

<pre><code class="language-PowerShell">$authparams = @{
    ClientId     = 'd1ddf0e4-d672-4dae-b554-9d5bdfd93547'
    TenantId     = 'powers-hell.com'
    ClientSecret = ('MySuperSecretClientSecret' | ConvertTo-SecureString -AsPlainText -Force)
}
$auth = Get-MsalToken @authParams
$auth
</code></pre>

<p>As is hopefully evident, the only tricky thing to remember here is you need to convert your client secret to a secure string type before sending it to the command.</p>

<h2 id="ok-ive-got-my-auth-token-now-what">Ok I’ve got my auth token. Now what?</h2>

<p>As you can see, there are many ways to authenticate to Graph. But if you don’t use it, why did we even bother?</p>

<p>The most important thing to understand is that within the returned authentication object in <strong>any</strong> of the above examples will be the <strong>access token</strong>. With that, we need to build an <em>Authorization</em> object to send along with all of our call to Graph. Luckily, this is super easy!</p>

<p>Below is a few examples of how to generate the authorization object to pull back a list of users from Graph.</p>

<h3 id="without-libraries-aka-the-manual-way">Without libraries (AKA the Manual way)</h3>

<h5 id="powershell-5--7">PowerShell 5 &amp; 7</h5>

<pre><code class="language-PowerShell">$authorizationHeader = @{
    Authorization = "Bearer $($auth.access_token)"
}
$requestBody = @{
    Method      = 'Get'
    Uri         = 'https://graph.microsoft.com/v1.0/users'
    Headers     = $authorizationHeader
    ContentType = 'Application/Json'
}
$response = Invoke-RestMethod @requestBody
$response
</code></pre>

<h5 id="powershell-7-only-aka-the-new-method">PowerShell 7 ONLY (AKA the new method)</h5>

<p>This method is relatively new &amp; only works in PowerShell 7. Instead of creating the authorization header manually, we can get the Invoke-RestMethod to build it for us!</p>

<pre><code class="language-PowerShell">$requestBody = @{
    Method          = 'Get'
    Uri             = 'https://graph.microsoft.com/v1.0/users'
    Authentication  = 'OAuth'
    Token           = ($auth.access_token | ConvertTo-SecureString -AsPlainText -Force)
    ContentType     = 'Application/Json'
}
$response = Invoke-RestMethod @requestBody
$response
</code></pre>

<p>As you can see, this is a bit cleaner - all we need to do is define that the token was derived from an OAuth request, and then convert the access token to a secure string.</p>

<h3 id="with-msal">With MSAL</h3>

<h5 id="powershell-5--7-1">PowerShell 5 &amp; 7</h5>

<p>The MSAL.PS module exposes some of the methods within the libraries to help us build the authorization header - if you find typing things difficult..</p>

<pre><code class="language-PowerShell">$authorizationHeader = @{
    Authorization = $auth.CreateAuthorizationHeader()
}
$requestBody = @{
    Method      = 'Get'
    Uri         = 'https://graph.microsoft.com/v1.0/users'
    Headers     = $authorizationHeader
    ContentType = 'Application/Json'
}
$response = Invoke-RestMethod @requestBody
$response
</code></pre>

<h5 id="powershell-7-only-aka-the-new-method-1">PowerShell 7 ONLY (AKA the new method)</h5>

<p>And finally, for completeness, we can use the new Invoke-RestMethod parameters with MSAL to really show off. The only thing to note of difference here is that the <em>access token</em> property returned from the MSAL call is named <strong>AccessToken</strong> compared to the native HTTP request which is <strong>Access_Token</strong></p>

<pre><code class="language-PowerShell">$requestBody = @{
    Method          = 'Get'
    Uri             = 'https://graph.microsoft.com/v1.0/users'
    Authentication  = 'OAuth'
    Token           = ($auth.AccessToken | ConvertTo-SecureString -AsPlainText -Force)
    ContentType     = 'Application/Json'
}
$response = Invoke-RestMethod @requestBody
$response
</code></pre>

<p>And there it is - Authentication to Graph with PowerShell in 2021. If you learned anything from this article, please feel free to share it and let me know via <a href="https://twitter.com/powers_hell">twitter</a>.</p>

<p>Hopefully that’s the last time I need to speak about authentication for another year!</p>

<p>— Ben</p>]]></content><author><name>Ben</name></author><category term="PowerShell" /><category term="Graph" /><category term="ADAL IS DEAD" /><category term="Authentication" /><category term="PowerShell" /><category term="Graph" /><category term="ADAL IS DEAD" /><category term="Authentication" /><summary type="html"><![CDATA[Talking about ways to authenticate to Graph is one of my least favourite subjects. After a while it gets a bit monotonous, but as with all technologies, things change..]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://powers-hell.com/assets/images/2021/07/msal-authentication-2021.gif" /><media:content medium="image" url="https://powers-hell.com/assets/images/2021/07/msal-authentication-2021.gif" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Create &amp;amp; assign filters with PowerShell &amp;amp; Graph</title><link href="https://powers-hell.com/2021/07/04/create-assign-filters-with-powershell-graph/" rel="alternate" type="text/html" title="Create &amp;amp; assign filters with PowerShell &amp;amp; Graph" /><published>2021-07-04T02:17:00+00:00</published><updated>2021-07-04T02:17:00+00:00</updated><id>https://powers-hell.com/2021/07/04/create-assign-filters-with-powershell-graph</id><content type="html" xml:base="https://powers-hell.com/2021/07/04/create-assign-filters-with-powershell-graph/"><![CDATA[<p>As I’ve said before, working with dynamic groups in Intune <a href="/2021/06/16/create-advanced-dynamic-groups-with-powershell-azure-functions/">isn’t my favourite thing</a>.</p>

<p>Luckily, Microsoft has been listening and have provided us with a better way to dynamically apply policies to devices with <a href="https://docs.microsoft.com/en-us/mem/intune/fundamentals/filters">filters!</a></p>

<!--more-->

<p>I recently sat down with <a href="https://twitter.com/scottduf">Scott Duffey</a> (who brought us this amazing new feature) to dive into how filters work and how they can improve our endpoint management workflows.</p>

<div class="video-container">
<iframe width="560" height="315" src="https://www.youtube.com/embed/_UuMfbvY8hw" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media;" allowfullscreen=""></iframe>
</div>

<p>As is always the case, after finishing our chat, I immediately wanted to figure out how to work with Filters in a more programmatic way. Turns out, it was super easy!</p>

<h2 id="overview">Overview</h2>

<p>At a high level, what makes filters so much better for use in Intune comes down to two primary factors.</p>

<ol>
  <li>The filter evaluation is done when the device enrolls, checks in with the Intune service or basically any time a policy is evaluated - which means the speed of evaluation is <em>significantly</em> faster than that of dynamic groups.</li>
  <li>Filters are decoupled from groups, which means they are now <strong>reusable</strong>. This means we can now create <strong>one</strong> filter and use it for <strong>many</strong> policies!</li>
</ol>

<p>So let’s get started and create our first filter.</p>

<h2 id="create-a-filter">Create a filter</h2>

<h5 id="authenticate">Authenticate</h5>

<p>As we are using PowerShell &amp; Graph, we will need to authenticate.</p>

<p>Using the MSAL.PS module makes this easy.</p>

<pre><code class="language-PowerShell">$authParams = @{
    ClientId    = 'd1ddf0e4-d672-4dae-b554-9d5bdfd93547'
    TenantId    = 'powers-hell.com'
    DeviceCode  = $true
}
$authToken = Get-MsalToken @authParams
</code></pre>

<h5 id="build-and-post">Build and post</h5>

<p>Now we need to build out a new filter object to post to Graph. This is just a simple json object that we will publish to the <strong>assignedFilters</strong> endpoint.</p>

<p>For this example we want a filter that finds all corporate owned virtual machines.</p>

<pre><code class="language-PowerShell">$filter = @{
    displayName = 'Example Filter'
    description = 'This filter will select all virtual machines'
    platform    = 'Windows10AndLater'
    rule        = '(device.deviceOwnership -eq "Corporate") and (device.model -startsWith "Virtual Machine")'
} | ConvertTo-Json -Depth 10
</code></pre>
<p>As you can see from above, the actual request body is quite simple. The actual filter rule uses the same syntax and formatting as dynamic rules, so the learning curve is quite low.</p>

<p>Now lets post our filter to graph.</p>

<pre><code class="language-PowerShell">$baseGraphUri = 'https://graph.microsoft.com/beta/deviceManagement/assignmentFilters'
$graphParams = @{
    Method          = 'Post'
    Uri             = $baseGraphUri
    Authentication  = 'OAuth'
    Token           = $authToken.AccessToken | ConvertTo-SecureString -AsPlainText -Force
    ContentType     = 'Application/Json'
    Body            = $filter
}
Invoke-RestMethod @graphParams
</code></pre>

<p>If successful, we should see the results of the post sent back to us. Make note of the returned id, and let’s move on!</p>

<p><a href="/assets/images/2021/07/image1.gif" title="Successful filter post"><img src="/assets/images/2021/07/image1.gif" alt="Successful filter post" /></a></p>

<h2 id="assign-a-filter">Assign a filter</h2>

<p>Now that we’ve got our filter created, let’s assign it to a policy. In this example, I’ve got an application I want to deploy (as required) to all of my virtual machines. To make sure I capture all possible virtual machines, I’ll assign the application to <strong>all devices</strong> and then filter down to the virtual machines using the filter object we’ve already created.</p>

<p>The first most obvious thing we need to do is know what the id of the policy is that we want. The easiest way to get that is to simply go to the policy in the endpoint portal.</p>

<p>Once you’ve got both the policy id and the filter id (from the creation steps above) , all that we need to do is build another post request to graph.</p>

<p>First, let’s build the body of the post.</p>

<pre><code class="language-PowerShell">$filterId = '2727f0f4-d030-4792-8aba-b6ef5efe602d' #your filter id
$assignments = @{
    mobileAppAssignments = @(
        @{
            '@odata.type' = '#microsoft.graph.mobileAppAssignment'
            intent        = 'Required'
            target        = @{
                '@odata.type'                              = '#microsoft.graph.allDevicesAssignmentTarget'
                deviceAndAppManagementAssignmentFilterId   = $filterId
                deviceAndAppManagementAssignmentFilterType = 'include'
            }
        }
    )
} | ConvertTo-Json -Depth 10
</code></pre>

<p>This is a <em>little</em> more complicated that the previous request we built, but only because we are dealing with nested objects. Simply speaking, all we are doing is creting a new <strong>required</strong> assignment pointing at the <strong>microsoft.graph.allDevicesAssignmentTarget</strong> object, and <strong>including</strong> our filter as part of the assignment.</p>

<p>If you were to replicate this experience, but use your own security groups, you’d simply change the target <strong>odata.type</strong> to <code class="language-plaintext highlighter-rouge">microsoft.graph.groupAssignmentTarget</code> and add a <strong>groupId</strong> property underneath it, as shown below.</p>

<pre><code class="language-PowerShell">$filterId = '2727f0f4-d030-4792-8aba-b6ef5efe602d' #your filter id
$groupId = 'da630732-10ac-47ae-94f9-2e5b9042109c' #your group id
$assignments = @{
    mobileAppAssignments = @(
        @{
            '@odata.type' = '#microsoft.graph.mobileAppAssignment'
            intent        = 'Required'
            target        = @{
                '@odata.type'                              = '#microsoft.graph.groupAssignmentTarget',
                groupId                                    = $groupId,
                deviceAndAppManagementAssignmentFilterId   = $filterId
                deviceAndAppManagementAssignmentFilterType = 'include'
            }
        }
    )
} | ConvertTo-Json -Depth 10
</code></pre>

<p>Similarly, if you wanted to <strong>exclude</strong> the objects captured in the filter group, change the <strong>deviceAndAppManagementAssignmentFilterType</strong> property to <strong>exclude</strong> - amazing, isn’t it!</p>

<p>Now that we have our request body formed, let’s post it to our policy.</p>

<pre><code class="language-PowerShell">$policyId = '149bf3d2-56cf-4cda-a3ea-79b6adb1c638' #your application policy id
$baseGraphUri = 'https://graph.microsoft.com/beta/deviceAppManagement/mobileApps/{0}/assign' -f $policyId
$graphParams = @{
    Method         = 'Post'
    Uri            = $baseGraphUri
    Authentication = 'OAuth'
    Token          = $authToken.AccessToken | ConvertTo-SecureString -AsPlainText -Force
    ContentType    = 'Application/Json'
    Body           = $assignments
}
Invoke-RestMethod @graphParams
</code></pre>

<p>Post requests to the assign endpoint don’t return anything back to us, but as long as we don’t get any errors, we should be good to go.</p>

<p><a href="/assets/images/2021/07/image2.gif" title="Successful assignment"><img src="/assets/images/2021/07/image2.gif" alt="Successful assignment" /></a></p>

<p>How simple is that!</p>

<p>Now, thanks to filters, you can start scoping policies and applications to larger groups, and use filters to tighten up the scope in a simple reusable fashion.</p>

<p>— Ben</p>]]></content><author><name>Ben</name></author><category term="PowerShell" /><category term="Automation" /><category term="Graph" /><category term="Intune" /><category term="PowerShell" /><category term="Automation" /><category term="Graph" /><category term="Intune" /><summary type="html"><![CDATA[As I’ve said before, working with dynamic groups in Intune isn’t my favourite thing. Luckily, Microsoft has been listening and have provided us with a better way to dynamically apply policies to devices with filters!]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://powers-hell.com/assets/images/2021/07/image2.gif" /><media:content medium="image" url="https://powers-hell.com/assets/images/2021/07/image2.gif" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Create advanced dynamic groups with PowerShell &amp;amp; Azure Functions</title><link href="https://powers-hell.com/2021/06/16/create-advanced-dynamic-groups-with-powershell-azure-functions/" rel="alternate" type="text/html" title="Create advanced dynamic groups with PowerShell &amp;amp; Azure Functions" /><published>2021-06-16T06:56:00+00:00</published><updated>2021-06-16T06:56:00+00:00</updated><id>https://powers-hell.com/2021/06/16/create-advanced-dynamic-groups-with-powershell-azure-functions</id><content type="html" xml:base="https://powers-hell.com/2021/06/16/create-advanced-dynamic-groups-with-powershell-azure-functions/"><![CDATA[<p>I’ve never been entirely happy with dynamic groups in Intune. The primary reason for this boils down to two primary issues:</p>

<ul>
  <li>The time it takes to analyze the dynamic group rules is nowhere near fast enough.</li>
  <li>The available properties available for dynamic group rules are limited to the data available in AAD - not Intune.</li>
</ul>

<!--more-->

<p>While the first issue has been remediated with the introduction of <a href="https://docs.microsoft.com/en-us/mem/intune/fundamentals/filters">filters</a>, the fact that I can’t create a rule on ANY property I want still bugs me.</p>

<p>I recently sat down with my good friend <a href="https://twitter.com/OnPremCloudGuy">Steven Hosking</a> and discussed ways to create dynamic groups using Power Automate, proving that with a little bit of effort (and deep-diving into Graph), you can build dynamic groups using custom logic. Check out the video below.</p>

<div class="video-container">
    <iframe src="https://www.youtube.com/embed/OLIA5_YW0Pg" title="S02E36 - Building Custom Dynamic Groups with Power Automate - (I.T)" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media;" allowfullscreen=""></iframe>
</div>

<p>Now that we know how <em>relatively simple</em> it is to build out custom dynamic groups with Power Automate, Let’s look into how we can achieve the same result with nothing but PowerShell &amp; Azure Functions.</p>

<h2 id="overview">Overview</h2>

<p>Like the video above, we can make sure that compliant devices are members of a specific security group. If they are no longer compliant, we want to make sure they are removed.</p>

<p>The solution we will build has two core elements:</p>

<ul>
  <li>An AAD application configured with <strong>application-scoped</strong> API permissions.</li>
  <li>An Azure function app to handle the group membership logic.</li>
</ul>

<h2 id="aad-application">AAD application</h2>

<ul>
  <li><a href="https://docs.microsoft.com/en-us/azure/active-directory/develop/quickstart-register-app">Create an AAD application</a> with the following API permissions:</li>
</ul>

<table>
  <thead>
    <tr>
      <th>API Permission Name</th>
      <th>Type</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Device.Read.All</td>
      <td>Application</td>
    </tr>
    <tr>
      <td>DeviceManagementManagedDevices.Read.All</td>
      <td>Application</td>
    </tr>
    <tr>
      <td>Group.Read.All</td>
      <td>Application</td>
    </tr>
    <tr>
      <td>GroupMember.ReadWrite.All</td>
      <td>Application</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>Grant admin consent for the above permissions.</li>
  <li>Generate a <strong>client secret</strong> and store it, along with the <strong>application ID</strong> for future use.</li>
</ul>

<h2 id="function-application">Function application</h2>

<p>Create a <strong>consumption</strong> function app (either in the <a href="https://docs.microsoft.com/en-us/azure/azure-functions/functions-create-function-app-portal">Azure portal</a>, or <a href="https://docs.microsoft.com/en-us/azure/azure-functions/create-first-function-vs-code-powershell">VSCode</a>).</p>

<p><a href="/assets/images/2021/06/functionapp.png" title="Basic function app creation"><img src="/assets/images/2021/06/functionapp.png" alt="Basic function app creation" /></a></p>

<p>From here on out, I’ll be sharing screens from VSCode, but you can achieve the same results directly from the portal as well.</p>

<p><a href="/assets/images/2021/06/pwsh_001.gif" title="Function app creation in VSCode"><img src="/assets/images/2021/06/pwsh_001.gif" alt="Function app creation in VSCode" /></a></p>

<blockquote>
  <p><strong>Tip:</strong> Because this function app doesn’t rely on any external modules, we can speed up its <strong>cold-start</strong> performance by setting <code class="language-plaintext highlighter-rouge">managedDependency enabled</code> value to <strong>false</strong> in the host.json file.
<a href="/assets/images/2021/06/pwsh_002.png" title="disable managed dependency for faster cold start times"><img src="/assets/images/2021/06/pwsh_002.png" alt="disable managed dependency for faster cold start times" /></a></p>
</blockquote>

<p>Once you have your function app created, we will need to set up the following application variables:</p>

<table>
  <thead>
    <tr>
      <th>Variable Name</th>
      <th>Variable Value</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>TENANT_ID</td>
      <td><strong>Your tenant ID \ AAD domain name</strong></td>
    </tr>
    <tr>
      <td>APPLICATION_ID</td>
      <td><strong>Your AAD application ID</strong></td>
    </tr>
    <tr>
      <td>CLIENT_SECRET</td>
      <td><strong>Your AAD application client secret</strong></td>
    </tr>
    <tr>
      <td>GROUP_ID</td>
      <td><strong>The object id of the security group you want to manage</strong></td>
    </tr>
  </tbody>
</table>

<p>For those who want to build this locally, you can put the above variables in your <strong>local.settings.json</strong> file within your function app project.</p>

<p><a href="/assets/images/2021/06/pwsh_004.png" title="local.settings.json"><img src="/assets/images/2021/06/pwsh_004.png" alt="local.settings.json" /></a></p>

<p>Now comes the fun part. Writing the function app logic. The script can be broken down into three main parts:</p>

<ul>
  <li>Authentication</li>
  <li>Getting compliance data with Graph</li>
  <li>Adding / Deleting group memberships with Graph</li>
</ul>

<p>Let’s look at each section now.</p>

<h3 id="authentication">Authentication</h3>

<p>Nothing super fancy here - I’ve discussed the ways to authenticate to Graph many times before. We will leverage the app variables we set up earlier to authenticate to our AAD application and store the token for the next few steps of the solution.</p>

<pre><code class="language-PowerShell">function Get-AuthHeader {
    param (
        [Parameter(mandatory = $true)]
        [string]$TenantId,
        [Parameter(mandatory = $true)]
        [string]$ClientId,
        [Parameter(mandatory = $true)]
        [string]$ClientSecret,
        [Parameter(mandatory = $true)]
        [string]$ResourceUrl
    )
    $body = @{
        resource      = $ResourceUrl
        client_id     = $ClientId
        client_secret = $ClientSecret
        grant_type    = "client_credentials"
        scope         = "openid"
    }
    try {
        $response = Invoke-RestMethod -Method post -Uri "https://login.microsoftonline.com/$TenantId/oauth2/token" -Body $body -ErrorAction Stop
        $headers = @{ "Authorization" = "Bearer $($response.access_token)" }
        return $headers
    }
    catch {
        Write-Error $_.Exception
    }
}
$params = @{
    TenantId     = $env:TENANT_ID
    ClientId     = $env:CLIENT_ID
    ClientSecret = $env:CLIENT_SECRET
    ResourceUrl  = "https://graph.microsoft.com"
}
$authHeader = Get-AuthHeader @params
</code></pre>

<h3 id="compliance-validation">Compliance validation</h3>

<p>Now that we have authenticated into Graph let’s grab all the devices and check their compliance state.</p>

<pre><code class="language-PowerShell">$graphUri = 'https://graph.microsoft.com/Beta/deviceManagement/managedDevices'
$params = @{
    Method      = 'Get'
    Headers     = $authHeader
    Uri         = $graphUri
    ContentType = 'Application/Json'
}
$query = Invoke-RestMethod @params
</code></pre>

<p>The results of the query are now stored in the <code class="language-plaintext highlighter-rouge">$query</code> variable. If we dive into the returned object data, selecting only the properties we want to see, we should start seeing some usable data.</p>

<pre><code class="language-PowerShell">$query.Value | Select-Object deviceName, complianceState
</code></pre>

<p><a href="/assets/images/2021/06/pwsh_003.gif" title="results of our first Graph query"><img src="/assets/images/2021/06/pwsh_003.gif" alt="results of our first Graph query" /></a></p>

<p>Now we know how to capture the compliance state of our devices, we can move onto managing their group memberships!</p>

<h3 id="managing-group-memberships">Managing group memberships</h3>

<p>Because security groups in Azure are an <em>AAD thing</em> we need to trade the Intune device object we got in the previous code snippet for the AAD device object. Luckily, the Intune object above contains the <strong>azureADDeviceId</strong> property, so it’s easy to get what we need. Let’s see how we would get the AAD object of just one of the devices in the returned objects.</p>

<pre><code class="language-PowerShell">$firstDevice = $query.Value[0]
$graphUri = "https://graph.microsoft.com/beta/devices?`$filter=deviceId eq '$($firstDevice.azureADDeviceId)'"
$params = @{
    Method      = 'Get'
    Headers     = $authHeader
    Uri         = $graphUri
    ContentType = 'Application/Json'
}
$AADDevice = Invoke-RestMethod @params
$AADDevice.Value
</code></pre>

<p>Now let’s get the current group members of the security group we want to manage.</p>

<pre><code class="language-PowerShell">$graphUri = "https://graph.microsoft.com/beta/groups/$env:GROUP_ID/members"
$params = @{
    Method      = 'Get'
    Headers     = $authHeader
    Uri         = $graphUri
    ContentType = 'Application/Json'
}
$groupMembers = Invoke-RestMethod @params
</code></pre>

<p>Let’s check if the device is already a member - if it’s not and the <strong>complianceState</strong> value is true, let’s add it.</p>

<pre><code class="language-PowerShell">if ($firstDevice.complianceState -eq "Compliant") {
    if ($groupMembers.value -notcontains $AADDevice.value[0].deviceId) {
        #region Device is compliant and not in the group
        $graphUri = "https://graph.microsoft.com/v1.0/groups/$env:GROUP_ID/members/`$ref"
        $params = @{
            Method      = 'Post'
            Headers     = $authHeader
            Uri         = $graphUri
            ContentType = 'Application/Json'
            body        = @{"@odata.id" = "https://graph.microsoft.com/v1.0/directoryObjects/$($AADDevice.value[0].id)" } | ConvertTo-Json
        }
        Invoke-RestMethod @params
        #endregion
    }
}
</code></pre>

<p>Conversely, if the device is NOT compliant and exists in the group, let’s handle that as well.</p>

<pre><code class="language-PowerShell">if ($firstDevice.complianceState -ne "Compliant") {
    if ($groupMembers.value -contains $AADDevice.value[0].deviceId) {
        #region device not compliant and exists in group
        $graphUri = "https://graph.microsoft.com/v1.0/groups/$env:GROUP_ID/members/$($AADDevice.value[0].id)/`$ref"
        $params = @{
            Method      = 'DELETE'
            Headers     = $authHeader
            Uri         = $graphUri
            ContentType = 'Application/Json'
        }
        Invoke-RestMethod @params
        #endregion
    }
}
</code></pre>

<p>So now we have the basic logic for our function app, with a bit of refactoring (to remove duplicate code) some code to help us build a result output, we should end up with a solution that will add all of my compliant devices to a security group!</p>

<pre><code class="language-PowerShell">using namespace System.Net

# Input bindings are passed in via param block.
param($Request, $TriggerMetadata)
$result = [System.Collections.ArrayList]::new()
$expectedComplianceValue = "compliant"
#region functions
function Get-AuthHeader {
    param (
        [Parameter(mandatory = $true)]
        [string]$TenantId,
        [Parameter(mandatory = $true)]
        [string]$ClientId,
        [Parameter(mandatory = $true)]
        [string]$ClientSecret,
        [Parameter(mandatory = $true)]
        [string]$ResourceUrl
    )
    $body = @{
        resource      = $ResourceUrl
        client_id     = $ClientId
        client_secret = $ClientSecret
        grant_type    = "client_credentials"
        scope         = "openid"
    }
    try {
        $response = Invoke-RestMethod -Method post -Uri "https://login.microsoftonline.com/$TenantId/oauth2/token" -Body $body -ErrorAction Stop
        $headers = @{ "Authorization" = "Bearer $($response.access_token)" }
        return $headers
    }
    catch {
        Write-Error $_.Exception
    }
}
function Invoke-GraphCall {
    [cmdletbinding()]
    param (
        [parameter(Mandatory = $false)]
        [ValidateSet('Get', 'Post', 'Delete')]
        [string]$Method = 'Get',

        [parameter(Mandatory = $false)]
        [hashtable]$Headers = $script:authHeader,

        [parameter(Mandatory = $true)]
        [string]$Uri,

        [parameter(Mandatory = $false)]
        [string]$ContentType = 'Application/Json',

        [parameter(Mandatory = $false)]
        [hashtable]$Body
    )
    try {
        $params = @{
            Method      = $Method
            Headers     = $Headers
            Uri         = $Uri
            ContentType = $ContentType
        }
        if ($Body) {
            $params.Body = $Body | ConvertTo-Json -Depth 20
        }
        $query = Invoke-RestMethod @params
        return $query
    }
    catch {
        Write-Warning $_.Exception.Message
    }
}
function Format-Result {
    [cmdletbinding()]
    param (
        [parameter(Mandatory = $true)]
        [string]$DeviceID,

        [parameter(Mandatory = $true)]
        [bool]$IsCompliant,

        [parameter(Mandatory = $true)]
        [bool]$IsMember,

        [parameter(Mandatory = $true)]
        [ValidateSet('Added', 'Removed', 'NoActionTaken')]
        [string]$Action
    )
    $result = [PSCustomObject]@{
        DeviceID    = $DeviceID
        IsCompliant = $IsCompliant
        IsMember    = $IsMember
        Action      = $Action
    }
    return $result
}
#endregion
#region authentication
$params = @{
    TenantId     = $env:TENANT_ID
    ClientId     = $env:CLIENT_ID
    ClientSecret = $env:CLIENT_SECRET
    ResourceUrl  = "https://graph.microsoft.com"
}
$script:authHeader = Get-AuthHeader @params
#endregion
#region get devices &amp; group members
$graphUri = 'https://graph.microsoft.com/Beta/deviceManagement/managedDevices'
$query = Invoke-GraphCall -Uri $graphUri

$graphUri = "https://graph.microsoft.com/beta/groups/$env:GROUP_ID/members"
$groupMembers = Invoke-GraphCall -Uri $graphUri
#endregion
#region check each device.
foreach ($device in $query.value) {
    #region get aad object from intune object
    $graphUri = "https://graph.microsoft.com/beta/devices?`$filter=deviceId eq '$($device.azureADDeviceId)'"
    $AADDevice = (Invoke-GraphCall -Uri $graphUri).value
    #endregion
    if ($device.complianceState -eq $expectedComplianceValue) {
        if ($groupMembers.value.deviceId -notcontains $AADDevice.deviceId) {
            #region Device is compliant and not in the group
            $graphUri = "https://graph.microsoft.com/v1.0/groups/$env:GROUP_ID/members/`$ref"
            $body = @{"@odata.id" = "https://graph.microsoft.com/v1.0/directoryObjects/$($AADDevice.id)" }
            Invoke-GraphCall -Uri $graphUri -Method Post -Body $body
            $result.Add($(Format-Result -DeviceID $device.id -IsCompliant $true -IsMember $true -Action Added)) | Out-Null
            #endregion
        }
        else {
            #region device is compliant and already a member
            $result.Add($(Format-Result -DeviceID $device.id -IsCompliant $true -IsMember $true -Action NoActionTaken)) | Out-Null
            #endregion
        }
    }
    else {
        if ($groupMembers.value.deviceId -contains $AADDevice.deviceId) {
            #region device not compliant and exists in group
            $graphUri = "https://graph.microsoft.com/v1.0/groups/$env:GROUP_ID/members/$($AADDevice.id)/`$ref"
            Invoke-GraphCall -Uri $graphUri -Method Delete
            $result.Add($(Format-Result -DeviceID $device.id -IsCompliant $false -IsMember $false -Action Removed)) | Out-Null
            #endregion
        }
        else {
            #region device not compliant and is not a member
            $result.Add($(Format-Result -DeviceID $device.id -IsCompliant $false -IsMember $false -Action NoActionTaken))
            #endregion
        }
    }
}
#endregion
# Associate values to output bindings by calling 'Push-OutputBinding'.
Push-OutputBinding -Name Response -Value ([HttpResponseContext]@{
        StatusCode = [HttpStatusCode]::OK
        Body       = $result | ConvertTo-Json -Depth 20
    })
</code></pre>

<p>If we now spin up a local instance of our function app (or run it from Azure for those testing in production🤠) we can trigger the function app from the URI and see the results…</p>

<p><a href="/assets/images/2021/06/pwsh_005.gif" title="It lives!"><img src="/assets/images/2021/06/pwsh_005.gif" alt="It lives!" /></a></p>

<p>Awesome! Now, there is more that needs to be done before this could be safely used in production - specifically putting in some logic to handle large amounts of devices via batched Graph calls and I’d be switching out the HTTP Trigger binding for a CRON job to automate the task, but I hope this will give you ideas for ways to build your dynamic group automation.</p>

<p>Don’t let the above example think you are limited to just properties via Graph either, keeping the HTTP trigger on the function app, I could imagine scenarios where proactive remediation scripts run on client devices to check for the presence of an application and force the function app to trigger..</p>

<p>As always, <a href="https://github.com/tabs-not-spaces/CodeDump/tree/master/Dynamic-Group-Automation">the full code from this article is available on Github</a></p>

<p>— Ben</p>]]></content><author><name>Ben</name></author><category term="PowerShell" /><category term="Azure" /><category term="Intune" /><category term="Azure Functions" /><category term="PowerShell" /><category term="Azure" /><category term="Intune" /><category term="Azure Functions" /><summary type="html"><![CDATA[I’ve never been entirely happy with dynamic groups in Intune. The primary reason for this boils down to two primary issues: The time it takes to analyze the dynamic group rules is nowhere near fast enough. The available properties available for dynamic group rules are limited to the data available in AAD - not Intune.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://powers-hell.com/assets/images/2021/06/pwsh_005.gif" /><media:content medium="image" url="https://powers-hell.com/assets/images/2021/06/pwsh_005.gif" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Working with Intune Settings Catalog using PowerShell and Graph</title><link href="https://powers-hell.com/2021/03/08/working-with-intune-settings-catalog-using-powershell-and-graph/" rel="alternate" type="text/html" title="Working with Intune Settings Catalog using PowerShell and Graph" /><published>2021-03-08T12:46:00+00:00</published><updated>2021-03-08T12:46:00+00:00</updated><id>https://powers-hell.com/2021/03/08/working-with-intune-settings-catalog-using-powershell-and-graph</id><content type="html" xml:base="https://powers-hell.com/2021/03/08/working-with-intune-settings-catalog-using-powershell-and-graph/"><![CDATA[<p>Microsoft has recently introduced even more ways to create device configuration profiles..</p>

<p>The new profile type, named <strong>Settings Catalog</strong>, allows us to explicitly define and configure a policy that has <strong>only</strong> the settings that they want for that profile, nothing more. Additionally, the existing configuration profiles and ADMX templates have been migrated to the <strong>templates</strong> profile type.</p>

<!--more-->

<p><a href="https://user-images.githubusercontent.com/33951277/119915226-66caae00-bfa5-11eb-8cc5-4eccfce7787e.png" title="Create a setting profile"><img src="https://user-images.githubusercontent.com/33951277/119915226-66caae00-bfa5-11eb-8cc5-4eccfce7787e.png" alt="" /></a></p>

<p>I sat down with <a href="https://twitter.com/MikeDanoski">Mike Danoski</a> for an in-depth chat about this on the <a href="https://intune.training" data-type="URL" data-id="https://intune.training">Intune.Training</a> Channel (video below).</p>

<div class="video-container">
    <iframe width="560" height="315" src="https://www.youtube.com/embed/sqIKcWXPvyI" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>
</div>

<p>After spending time with Mike and seeing how settings catalog profiles work from the endpoint portal user interface, I immediately wanted to see what I could do with this new device management framework via graph.</p>

<p>So let’s dive in and play!</p>

<h2 id="pulling-settings-catalog-policies-from-graph"><strong>Pulling settings catalog policies from Graph</strong></h2>

<p>First, let’s create a policy from the endpoint portal and see what is required to retrieve the policy data.</p>

<p>For this demo, I’ve created a simple settings catalog with a few settings around bitlocker as shown below.</p>

<p><a href="https://user-images.githubusercontent.com/33951277/119915357-ad200d00-bfa5-11eb-97fc-2cef877def1a.png"><img src="https://user-images.githubusercontent.com/33951277/119915357-ad200d00-bfa5-11eb-97fc-2cef877def1a.png" alt="image-1" /></a></p>

<p>The first thing we need to do, as always, is authenticate to graph - At this point I shouldn’t need to explain what is happening here. We will use the msal.ps module to make things easier.</p>

<pre class="wp-block-code" title="Configure Authentication for Graph."><code lang="powershell" class="language-powershell">$params = @{
    ClientId = 'd1ddf0e4-d672-4dae-b554-9d5bdfd93547'
    TenantId = 'powers-hell.com'
    DeviceCode = $true
}
$authHeaders = @{Authorization = (Get-MsalToken @params).CreateAuthorizationHeader()}</code></pre>

<p>Now that we’ve authenticated to graph, let’s use the new graph endpoint <strong>configurationPolicies</strong> to have a look at how this new feature looks in the backend.</p>

<pre class="wp-block-code" title="Get configurationPolicies"><code lang="powershell" class="language-powershell">$baseUri = "https://graph.microsoft.com/beta/deviceManagement"
$restParam = @{
    Method = 'Get'
    Uri = "$baseUri/configurationPolicies"
    Headers = $authHeaders
    ContentType = 'Application/json'
}

$configPolicies = Invoke-RestMethod @restParam
$configPolicies.value</code></pre>

<p>As you can see, the code above is quite simple, and looking at the resultant data shows we get some basic data back showing all available <strong>settings catalog</strong> policies that are in our tenant (in our case just the one).</p>

<p><a href="https://user-images.githubusercontent.com/33951277/119915408-ca54db80-bfa5-11eb-9be7-d9d02f8cd82c.png"><img src="https://user-images.githubusercontent.com/33951277/119915408-ca54db80-bfa5-11eb-9be7-d9d02f8cd82c.png" alt="image-2" /></a></p>

<p>Ok, so we’ve got the basic metadata of our policy - so let’s grab the id from the previous call and dive in further..</p>

<pre><code class="language-PowerShell">$policyId = $configPolicies.value[0].id #grabbing the id from the previous code block
$restParam = @{
    Method = 'Get'
    Uri = "$baseUri/configurationPolicies('$policyId')/settings"
    Headers = $authHeaders
    ContentType = 'Application/json'
}

$configPolicySettings = Invoke-RestMethod @restParam
$configPolicySettings.value
</code></pre>

<p>The code above returns data on all available settings that we configured in our policy..</p>

<p><a href="https://user-images.githubusercontent.com/33951277/119915446-e5bfe680-bfa5-11eb-95ee-c997cae4af14.png"><img src="https://user-images.githubusercontent.com/33951277/119915446-e5bfe680-bfa5-11eb-95ee-c997cae4af14.png" alt="image-3" /></a></p>

<p>if we drill in to one of the <strong>settingInstance</strong> objects, we should see more info..</p>

<p><a href="https://user-images.githubusercontent.com/33951277/119915455-ea849a80-bfa5-11eb-8e0a-e3b960be372e.png"><img src="https://user-images.githubusercontent.com/33951277/119915455-ea849a80-bfa5-11eb-8e0a-e3b960be372e.png" alt="image-4" /></a></p>

<p>As we can see, this particular setting is for <strong>allow warning for other disk encryption</strong> - as clearly defined in the <strong>definitionId</strong> value. If we drill into the <strong>choiceSettingValue</strong> item, we will see the applied value and any other child properties within that setting..</p>

<p><a href="https://user-images.githubusercontent.com/33951277/119915465-efe1e500-bfa5-11eb-868b-3201648c081f.png"><img src="https://user-images.githubusercontent.com/33951277/119915465-efe1e500-bfa5-11eb-868b-3201648c081f.png" alt="image-5" /></a></p>

<p>Here we can see the value of <strong>allow warning for other disk encryption</strong> is set to 0 - or false, which correlates to our policy set from the endpoint portal.</p>

<p><a href="https://user-images.githubusercontent.com/33951277/119915536-1011a400-bfa6-11eb-8421-eeca2c61bcb9.png"><img src="https://user-images.githubusercontent.com/33951277/119915536-1011a400-bfa6-11eb-8421-eeca2c61bcb9.png" alt="image-6" /></a></p>

<p>Here we can see the <strong>child</strong> setting of <strong>allow standard user encryption</strong> with the setting value of 1 - or true.</p>

<p>This example shows how simple it is to capture the basic building blocks of a settings catalog policy. But for those interested to dig deeper, why not check out what happens when you run the same example from above while expanding the <strong>settingDefinitions</strong> property..</p>

<p><a href="https://user-images.githubusercontent.com/33951277/119915557-1acc3900-bfa6-11eb-8374-b50a0a1b2d82.gif"><img src="https://user-images.githubusercontent.com/33951277/119915557-1acc3900-bfa6-11eb-8374-b50a0a1b2d82.gif" alt="settingsDefinition" /></a></p>

<p>Cool, huh? literally everything about each and every setting is available to us if we just spend the time to dig into graph a little bit!</p>

<h2 id="building-a-policy-from-scratch">Building a policy from scratch</h2>

<p>Now, before we begin, I’m going to put this out there - settings catalog policies are probably not the easiest things to build from scratch..</p>

<p>There is LOTS of metadata that you need to know for each setting before you can build out the policies. However, the concepts shown below can also be leveraged to maintain <strong>reference templates</strong> that can be captured and redeployed to other tenants to allow seamless management of multiple tenants with minimal effort.</p>

<p>Enough stalling, let’s see what’s required.</p>

<h3 id="getting-all-settings-data">Getting all settings data</h3>

<p>So the first question that you may be asking, is, “How do I get the data that I need for the settings that I want to add to my catalog policy?” Luckily, Microsoft has an endpoint in graph that will return all possible settings currently available for the settings catalog.</p>

<p>We can capture all necessary metadata on those available settings by using the <strong>deviceManagement/configurationSettings</strong> endpoint.</p>

<pre><code class="language-PowerShell">$restParam = @{
    Method = "Get"
    Uri = "$baseUri/configurationSettings"
    Headers = $authHeaders
    ContentType = 'Application/Json'
}
$settingsData = Invoke-RestMethod @restParam
$settingsData.value
</code></pre>

<p>Let’s run the above code and see what we get back..</p>

<p><a href="https://user-images.githubusercontent.com/33951277/119915626-40f1d900-bfa6-11eb-9bd0-cab0d19c0e2f.gif"><img src="https://user-images.githubusercontent.com/33951277/119915626-40f1d900-bfa6-11eb-9bd0-cab0d19c0e2f.gif" alt="settingsCatapalooza" /></a></p>

<p>Well… that was a bit much wasn’t it! at the time of writing, there is around 2,100 settings available in the settings catalog library with more to come until it is at parity with all existing methods of device configuration (configuration items, ADMX templates, endpoint baselines etc).</p>

<p>Let’s filter the settings by a setting <strong>definitionId</strong> that we know (notice that the definitionId isnt a GUID? welcome to the future…)</p>

<pre><code class="language-PowerShell">$settingsData.value | where {$_.id -eq 'device_vendor_msft_bitlocker_allowwarningforotherdiskencryption'}
</code></pre>

<p><a href="https://user-images.githubusercontent.com/33951277/119915662-52d37c00-bfa6-11eb-8d82-623eafe6e2b1.png"><img src="https://user-images.githubusercontent.com/33951277/119915662-52d37c00-bfa6-11eb-8d82-623eafe6e2b1.png" alt="image-7" /></a></p>

<p>Weird… doesn’t that look the same as the expanded <strong>settingsDefinitions</strong> content from earlier? That’s because it is literally the same data! We can dig into this data to find out the available options for each setting, but let’s skip that for now and just build our example policy from scratch..</p>

<h3 id="posting-a-settings-catalog-policy-to-intune-from-graph">Posting a settings catalog policy to Intune from Graph</h3>

<p>Conceptually we now should understand what’s required here. We have some metadata around what the policy is called to which we attach whichever settings we want attributed to our new policy profile. So let’s rebuild the original policy in PowerShell!</p>

<pre><code class="language-PowerShell">$baseUri = 'https://graph.microsoft.com/beta/deviceManagement/configurationPolicies'

#region build the policy
$newPolicy = [pscustomobject]@{
    name         = "Bitlocker Policy from PowerShell"
    description  = "we built this from PowerShell!"
    platforms    = "windows10"
    technologies = "mdm"
    settings     = @(
        @{
            '@odata.type'   = "#microsoft.graph.deviceManagementConfigurationSetting"
            settingInstance = @{
                '@odata.type'       = "#microsoft.graph.deviceManagementConfigurationChoiceSettingInstance"
                settingDefinitionId = "device_vendor_msft_bitlocker_allowwarningforotherdiskencryption"
                choiceSettingValue  = @{
                    '@odata.type' = "#microsoft.graph.deviceManagementConfigurationChoiceSettingValue"
                    value         = "device_vendor_msft_bitlocker_allowwarningforotherdiskencryption_0"
                    children      = @(
                        @{
                            '@odata.type'       = "#microsoft.graph.deviceManagementConfigurationChoiceSettingInstance"
                            settingDefinitionId = "device_vendor_msft_bitlocker_allowstandarduserencryption"
                            choiceSettingValue  = @{
                                '@odata.type' = "#microsoft.graph.deviceManagementConfigurationChoiceSettingValue"
                                value         = "device_vendor_msft_bitlocker_allowstandarduserencryption_0"
                            }
                        }
                    )
                }
            }
        }
        @{
            '@odata.type'   = "#microsoft.graph.deviceManagementConfigurationSetting"
            settingInstance = @{
                '@odata.type'       = "#microsoft.graph.deviceManagementConfigurationChoiceSettingInstance"
                settingDefinitionId = "device_vendor_msft_bitlocker_requiredeviceencryption"
                choiceSettingValue  = @{
                    '@odata.type' = "#microsoft.graph.deviceManagementConfigurationChoiceSettingValue"
                    value         = "device_vendor_msft_bitlocker_requiredeviceencryption_1"
                }
            }
        }
    )
}
#endregion
#region post the request
$restParams = @{
    Method      = 'Post'
    Uri         = $baseUri
    body        = ($newPolicy | ConvertTo-Json -Depth 20)
    Headers     = $authHeaders
    ContentType = 'Application/Json'
}
Invoke-RestMethod @restParams
#endregion
</code></pre>

<p>Once we run this - within seconds we should have a replicated policy in our tenant!</p>

<p><a href="https://user-images.githubusercontent.com/33951277/119915697-65e64c00-bfa6-11eb-8cab-06a15f01b7e8.png"><img src="https://user-images.githubusercontent.com/33951277/119915697-65e64c00-bfa6-11eb-8cab-06a15f01b7e8.png" alt="image-8" /></a></p>

<p>As mentioned earlier, building these from scratch is tricky - but if you read between the lines, knowing how to capture pre-built policies via graph and using the captured JSON payload to post the same policy to a new tenant (or a few hundred tenants) should make multi-tenant device management less painful.</p>

<p>— Ben</p>]]></content><author><name>Ben</name></author><category term="Azure" /><category term="Graph" /><category term="Intune" /><category term="PowerShell" /><category term="Azure" /><category term="Intune" /><category term="PowerShell" /><summary type="html"><![CDATA[Microsoft has recently introduced even more ways to create device configuration profiles.. The new profile type, named Settings Catalog, allows us to explicitly define and configure a policy that has only the settings that they want for that profile, nothing more. Additionally, the existing configuration profiles and ADMX templates have been migrated to the templates profile type.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://powers-hell.com/assets/images/2021/03/settingsCatapalooza.gif" /><media:content medium="image" url="https://powers-hell.com/assets/images/2021/03/settingsCatapalooza.gif" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Publishing PowerShell scripts to Intune with Graph</title><link href="https://powers-hell.com/2021/01/19/publishing-powershell-scripts-to-intune-with-graph/" rel="alternate" type="text/html" title="Publishing PowerShell scripts to Intune with Graph" /><published>2021-01-19T03:22:12+00:00</published><updated>2021-01-19T03:22:12+00:00</updated><id>https://powers-hell.com/2021/01/19/publishing-powershell-scripts-to-intune-with-graph</id><content type="html" xml:base="https://powers-hell.com/2021/01/19/publishing-powershell-scripts-to-intune-with-graph/"><![CDATA[<p>I’ve recently been asked the question - “How can I make sure that the scripts that I publish to Intune are always set to run as 64bit instead of the default 32bit?”</p>

<p>I thought was a great question with a few simple solutions - so let’s look at the two methods I’ve used in the past to make sure you don’t “fat finger” your way into frustration!</p>

<!--more-->

<h2 id="enforce-architecture-from-the-script">Enforce architecture from the script</h2>

<p>When PowerShell script deployment was initially released within Intune there was no native way to define what architecture the script would run in. This means that the script would always run in the 32bit / x86 environment as the Intune Management Extension agent was launching the scripts and the agent itself was a 32bit agent - it had no way to bootstrap out of the 32bit environment!</p>

<p>The only solution during this period was to make your scripts bootstrap themselves into 64bit with a little bit of PowerShell magic.</p>

<pre><code class="language-PowerShell">#region 64-bit elevation
if ($env:PROCESSOR_ARCHITEW6432 -eq "AMD64") {
    write-Host "pull on those bootstraps..."
    if ($myInvocation.Line) {
        &amp;"$env:WINDIR\sysnative\windowspowershell\v1.0\powershell.exe" -NonInteractive -executionPolicy Bypass -NoProfile $myInvocation.Line
    }
    else {
        &amp;"$env:WINDIR\sysnative\windowspowershell\v1.0\powershell.exe" -NonInteractive -executionPolicy Bypass -NoProfile -file "$($myInvocation.InvocationName)" $args
    }
    exit $lastexitcode
}
#endregion
</code></pre>

<p>Place that code at the top of any script you publish to Intune and you can rest easy knowing that your code will always run in the environment it should be in, regardless if you set it correctly from within Intune or not.</p>

<h2 id="avoid-the-endpoint-ui-and-use-graph">Avoid the Endpoint UI and use Graph</h2>

<p>Now that the option to set the architecture from within the script deployment, the above solution is conceivably “redundant” - we can set everything when we publish the script in the portal now!</p>

<p>The problem arises however, because the default architecture setting is set to 32bit instead of the generally expected 64bit, that you can sometimes forget to set the configuration correctly from the portal.</p>

<p>Luckily, we can move away from the Endpoint portal and use PowerShell and Graph to change the default settings to values and standardize our script publishing to avoid any of those absent-minded “user errors” that are so frustratingly common.</p>

<p>Like all other configuration settings / device management endpoints that are exposed via Graph, all that is required is to:</p>

<ul>
  <li>Understand how the JSON payload data is formed</li>
  <li>Authenticate to Graph</li>
  <li>Build and publish the JSON payload to Graph</li>
</ul>

<p>The one extra step for script deployment is that we need to encode the script content into a base64 encoded string so that we can post the file within the JSON payload.</p>

<p>Let’s dive into the solution together.</p>

<h3 id="authentication">Authentication</h3>

<p>I’ve covered this ad-nauseum, so I won’t spend time explaining it - but here’s the code snippet we will use for this example. What’s cool about this is we can handle whether or not the end user uses PowerShell 5.1 or 7.</p>

<pre><code class="language-PowerShell">#region authenticate to Graph
if ($PSVersionTable.PSEdition -ne "Core") {
    $auth = Get-MsalToken -ClientId "d1ddf0e4-d672-4dae-b554-9d5bdfd93547" -RedirectUri "urn:ietf:wg:oauth:2.0:oob" -Interactive
}
else {
    $auth = Get-MsalToken -ClientId "d1ddf0e4-d672-4dae-b554-9d5bdfd93547" -DeviceCode
}
$script:authToken = @{
    Authorization = $auth.CreateAuthorizationHeader()
}
#endregion
</code></pre>

<h3 id="encode-the-script-to-a-base64-string">Encode the script to a base64 string</h3>

<p>Very simple - but super important. We just need to get the raw content of the script and throw it into the .Net “System.Convert” type.</p>

<pre><code class="language-PowerShell">#region encode the script content to base64
$scriptContent = Get-Content "C:\Path\To\Script.ps1" -Raw
$encodedScriptContent = [System.Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes("$scriptContent"))
#endregion
</code></pre>

<h3 id="payload-properties">Payload properties</h3>

<p>The required properties for publishing scripts to Graph are quite simple - the endpoint <strong>deviceManagementScripts</strong> is <a href="https://docs.microsoft.com/en-us/graph/api/intune-shared-devicemanagementscript-create?view=graph-rest-beta" data-type="URL" data-id="https://docs.microsoft.com/en-us/graph/api/intune-shared-devicemanagementscript-create?view=graph-rest-beta">well documented</a>, but for simplicity, the only settings we need to understand are listed below:</p>

<table>
  <thead>
    <tr>
      <th><strong>Property Name</strong></th>
      <th><strong>Data Type</strong></th>
      <th><strong>Description</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>displayName</td>
      <td>String</td>
      <td>Name of the device management script.</td>
    </tr>
    <tr>
      <td>description</td>
      <td>String</td>
      <td>Description of the script</td>
    </tr>
    <tr>
      <td>enforceSignatureCheck</td>
      <td>Boolean</td>
      <td>Setting this to False disables signature check.</td>
    </tr>
    <tr>
      <td>fileName</td>
      <td>String</td>
      <td>Name of the file being uploaded.</td>
    </tr>
    <tr>
      <td>runas32Bit</td>
      <td>Boolean</td>
      <td>Setting this to False sets to 64bit</td>
    </tr>
    <tr>
      <td>runAsAccount</td>
      <td>String</td>
      <td>Execution context - System or User</td>
    </tr>
    <tr>
      <td>scriptContent</td>
      <td>Binary</td>
      <td>Script content - encoded as base64</td>
    </tr>
  </tbody>
</table>

<p>So, knowing what we need, let’s build out the code to build the payload.</p>

<pre><code class="language-PowerShell">#region build the request body
$postBody = [PSCustomObject]@{
    displayName           = "Powers-Hell Configuration Script"
    description           = "script that configures important things"
    enforceSignatureCheck = $false
    fileName              = "Script.ps1"
    runAs32Bit            = $false
    runAsAccount          = "System"
    scriptContent         = $encodedScriptContent
} | ConvertTo-Json -Depth 10
#endregion
</code></pre>

<p>Quite simple - creating a PSCustomObject, filling in the property values and then immediately converting to a JSON string.</p>

<h3 id="post-the-request-to-graph">Post the request to Graph</h3>

<p>Once we’ve got out authentication header, we’ve encoded the script contents and built out the JSON payload, all that’s left to do is post the payload to the Graph endpoint.</p>

<pre><code class="language-PowerShell">#region post the request
$postParams = @{
    Method      = "Post"
    Uri         = "https://graph.microsoft.com/Beta/deviceManagement/deviceManagementScripts"
    Headers     = $script:authToken
    Body        = $postBody
    ContentType = "Application/Json"
}
Invoke-RestMethod @postParams
#endregion
</code></pre>

<p>If we use the above basic blocks of code, we can very easily build a simple function to allow us to build out a request to publish scripts to our Intune tenant and by forcing the boolean value of <strong>runAs32Bit</strong> to $false, we can ensure the script will always run correctly - even if we haven’t had enough coffee yet.</p>

<pre><code class="language-PowerShell">#requires -module msal.ps
function Publish-ScriptToIntune {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory = $true)]
        [System.IO.FileInfo]$ScriptFilePath,

        [Parameter(Mandatory = $true)]
        [string]$DisplayName,

        [Parameter(Mandatory = $true)]
        [string]$Description,

        [Parameter(Mandatory = $false)]
        [ValidateSet("System", "User")]
        [string]$RunAsAccount = "System",

        [Parameter(Mandatory = $false)]
        [boolean]$EnforceSignatureCheck,

        [Parameter(Mandatory = $false)]
        [boolean]$RunAs32Bit

    )
    try {
        $script:tick = [char]0x221a
        $errorMsg = $null
        #region authenticate to Graph
        if ($PSVersionTable.PSEdition -ne "Core") {
            $auth = Get-MsalToken -ClientId "d1ddf0e4-d672-4dae-b554-9d5bdfd93547" -RedirectUri "urn:ietf:wg:oauth:2.0:oob" -Interactive
        }
        else {
            $auth = Get-MsalToken -ClientId "d1ddf0e4-d672-4dae-b554-9d5bdfd93547" -DeviceCode
        }
        if (!($auth)) {
            throw "Authentication failed."
        }
        $script:authToken = @{
            Authorization = $auth.CreateAuthorizationHeader()
        }
        #endregion
        #region encode the script content to base64
        $scriptContent = Get-Content "$ScriptFilePath" -Raw
        $encodedScriptContent = [System.Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes("$scriptContent"))
        #endregion
        #region build the request body
        $postBody = [PSCustomObject]@{
            displayName           = $DisplayName
            description           = $Description
            enforceSignatureCheck = $EnforceSignatureCheck
            fileName              = $ScriptFilePath.Name
            runAs32Bit            = $RunAs32Bit
            runAsAccount          = $RunAsAccount
            scriptContent         = $encodedScriptContent
        } | ConvertTo-Json -Depth 10
        #endregion
        Write-Host "`nPosting script content to Intune: " -NoNewline -ForegroundColor Cyan
        #region post the request
        $postParams = @{
            Method      = "Post"
            Uri         = "https://graph.microsoft.com/Beta/deviceManagement/deviceManagementScripts"
            Headers     = $script:authToken
            Body        = $postBody
            ContentType = "Application/Json"
        }
        if ($PSCmdlet.MyInvocation.BoundParameters["Verbose"].IsPresent) {
            Write-Host "`n"
        }
        $res = Invoke-RestMethod @postParams
        #endregion
    }
    catch {
        $errorMsg = $_.Exception.Message
    }
    finally {
        if ($auth) {
            if ($errorMsg) {
                Write-Host "X`n" -ForegroundColor Red
                Write-Warning $errorMsg
            }
            else {
                if ($PSCmdlet.MyInvocation.BoundParameters["Verbose"].IsPresent) {
                    $res
                }
                Write-Host "$script:tick Script published to Intune with ID $($res.id)" -ForegroundColor Green
            }
        }
    }
}
</code></pre>

<p>As always, the code featured is available in my <a href="https://github.com/tabs-not-spaces/CodeDump/tree/master/Publish-ScriptToIntune">GitHub</a> and I’m always up for a chat on <a href="https://twitter.com/powers_hell">Twitter</a>!</p>

<p>— Ben</p>]]></content><author><name>Ben</name></author><category term="Azure" /><category term="Graph" /><category term="Intune" /><category term="PowerShell" /><category term="Graph" /><category term="Intune" /><category term="PowerShell" /><summary type="html"><![CDATA[I've recently been asked the question - "How can I make sure that the scripts that I publish to Intune are always set to run as 64bit instead of the default 32bit?" I thought was a great question with a few simple solutions - so let's look at the two methods I've used in the past to make sure you don't "fat finger" your way into frustration!]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://powers-hell.com/assets/images/2021/01/scriptToGraph.gif" /><media:content medium="image" url="https://powers-hell.com/assets/images/2021/01/scriptToGraph.gif" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Set your Azure VPN connections to “Connect Automatically” with PowerShell</title><link href="https://powers-hell.com/2020/11/28/set-your-azure-vpn-connections-to-connect-automatically-with-powershell/" rel="alternate" type="text/html" title="Set your Azure VPN connections to “Connect Automatically” with PowerShell" /><published>2020-11-28T06:25:27+00:00</published><updated>2020-11-28T06:25:27+00:00</updated><id>https://powers-hell.com/2020/11/28/set-your-azure-vpn-connections-to-connect-automatically-with-powershell</id><content type="html" xml:base="https://powers-hell.com/2020/11/28/set-your-azure-vpn-connections-to-connect-automatically-with-powershell/"><![CDATA[<p>One of my clients recently came to me asking for assistance to set up a new VPN solution. The requirements were quite simple - They were building out an Azure Point-To-Site VPN solution and needed me to come up with a way to deliver the connection to the end user devices.</p>

<!--more-->

<p>My first suggestion was to simply use the built-in VPN client that comes with Windows 10. If we use this, we can utilize the native VPN policies within Intune which let us define everything we need - including setting the connection to automatically connect. The problem, as it turned out is the native VPN client has a limit of 25 route rules per connection - something that *shouldn’t* normally be a problem, but was insurmountable in this scenario.</p>

<p>The next suggestion was to leverage the <a href="https://www.microsoft.com/en-us/p/azure-vpn-client/9np355qt2sqb" data-type="URL" data-id="https://www.microsoft.com/en-us/p/azure-vpn-client/9np355qt2sqb">Azure VPN Client</a> from the Microsoft store. This VPN client is designed to compliment the native VPN client and adds support for MFA as well as allowing connections from the native VPN interface.</p>

<p>The only problem? There is no way to force the “connect automatically” setting in the native VPN client, thus the client’s major requirement was not met.</p>

<p>Now, the end user can technically go in once the connection is deployed and set it themselves, but there has to be a more reliable way of doing this on behalf of the user - if it can be done via Intune for the native client, surely there has to be a way to enforce the setting? The answer, as always, is a resounding “of course!”.</p>

<p>Before we begin, the first thing we need to do is convert the config files I was given by my network team into a format that we can silently push out.</p>

<p>Once you’ve downloaded the Azure P2S config files, the next step is to manually import the config into the Azure VPN client (technically there is a way to do this using CLI parameters, however it’s frustratingly broken at the moment - I’ll talk about that another time!).</p>

<p><a href="/assets/images/2020/11/VPNConnectionImport-1.gif" title="VPN Connection Import"><img src="/assets/images/2020/11/VPNConnectionImport-1.gif" alt="VPN Connection Import" /></a></p>

<p>What this manual step does is creates the *.PBK file that the VPN client uses to “dial the connection”. Once we have that *.PBK file generated, we can capture the contents, and then deploy it out to other devices via Intune (or Configuration Manager) using a very simple PowerShell script.</p>

<p>The *.PBK file is stored within the Azure VPN client folder structure in your local app data folder shown below - It’s always the same path which makes all of this very easy to automate!</p>

<p><strong>%localappdata%\Packages\Microsoft.AzureVpn_8wekyb3d8bbwe\LocalState\rasphone.pbk</strong></p>

<p>Open the *.pbk file in your favourite editor (that’s VSCode for everyone right?) and let’s move onto the code.</p>

<pre class="wp-block-code" title="Deploy and configure VPN"><code lang="powershell" class="language-powershell line-numbers">
#region Configuration
$VPNName = 'Powers Hell VPN Connection'
$VPNGUID = 'F3910F5AC434944F9335C187D7476DB4'
$currentUser = (Get-CimInstance -ClassName WIn32_Process -Filter 'Name="explorer.exe"' | Invoke-CimMethod -MethodName GetOwner)[0]
$objUser = New-Object System.Security.Principal.NTAccount($currentUser.user)
$strSID = $objUser.Translate([System.Security.Principal.SecurityIdentifier])
$requiredFolder = "C:\Users\$($currentUser.user)\AppData\Local\Packages\Microsoft.AzureVpn_8wekyb3d8bbwe\LocalState"
$rasManKeyPath = "HKLM:\SYSTEM\CurrentControlSet\Services\RasMan\Config"
#endregion
#region PBK Configuration
$PBKConfig - @"
#Place your PBK contents here...
"@
#endregion
#region Functions
function Write-Log {
    [cmdletbinding()]
    param (
        [string]$logMessage
    )
    Write-Host "[$(Get-Date -Format 'dd-MM-yyyy_HH:mm:ss')] $logMessage" -ForegroundColor Yellow
}
#endregion
#region Deploy VPN
if (!(Test-Path $RequiredFolder -ErrorAction SilentlyContinue)) {
  New-Item $RequiredFolder -ItemType Directory | Out-Null
  $LogLocation = "$RequiredFolder\NewAzureVPNConnectionLog_$(Get-Date -Format 'dd-MM-yyyy_HH_mm_ss').log"
  Start-Transcript -Path $LogLocation -Force -Append

  Write-Log "Required folder $RequiredFolder was created on the machine since it wasn't found."
  New-Item "$RequiredFolder\rasphone.pbk" -ItemType File | Out-Null

  Write-Log "File rasphone.pbk has been created in $RequiredFolder."
  Set-Content "$RequiredFolder\rasphone.pbk" $PBKConfig

  Write-Log "File rasphone.pbk has been populated with configuration details."
  Stop-Transcript | Out-Null
}
else {
  $LogLocation = "$RequiredFolder\NewAzureVPNConnectionLog_$(Get-Date -Format 'dd-MM-yyyy_HH_mm_ss').log"
  Start-Transcript -Path $LogLocation -Force -Append

  Write-Log "Folder $RequiredFolder already exists, that means that Azure VPN Client is already installed."
  if (!(Test-Path "$RequiredFolder\rasphone.pbk" -ErrorAction SilentlyContinue)) {

    Write-Log "File rasphone.pbk doesn't exist in $RequiredFolder."
    New-Item "$RequiredFolder\rasphone.pbk" -ItemType File | Out-Null

    Write-Log "File rasphone.pbk has been created in $RequiredFolder."
    Set-Content "$RequiredFolder\rasphone.pbk" $PBKConfig

    Write-Log "File rasphone.pbk has been populated with configuration details."
    Stop-Transcript | Out-Null
  }
  else {
    Write-Log "File rasphone.pbk already exists in $RequiredFolder."
    Rename-Item -Path "$RequiredFolder\rasphone.pbk" -NewName "$RequiredFolder\rasphone.pbk_$(Get-Date -Format 'ddMMyyyy-HHmmss')"

    Write-Log "File rasphone.pbk has been renamed to rasphone.pbk_$(Get-Date -Format 'ddMMyyyy-HHmmss'). This file contains old configuration if it will be required in the future (in case it is, just rename it back to rasphone.pbk)."
    New-Item "$RequiredFolder\rasphone.pbk" -ItemType File | Out-Null

    Write-Log "New rasphone.pbk file has been created in $RequiredFolder."
    Set-Content "$RequiredFolder\rasphone.pbk" $PBKConfig

    Write-Log "File rasphone.pbk has been populated with configuration details."
    Stop-Transcript | Out-Null
  }
}
#endregion</code></pre>

<p>Not much to be said about the above code - all we are doing is pushing out the contents of the *.PBK file to the correct location on the target machines. There is only one important thing to note - I’ve specifically replaced the name and guid from the *.PBK file with variable names to allow me to set them in the configuration at the top of the script. You don’t need to do that yourself, but it makes the solution a little more “reusable”.</p>

<p>You can see where they normally appear in the screenshot below (lines 1 &amp; 10).</p>

<p><a href="/assets/images/2020/11/image.png" title="PBK Snippet"><img src="/assets/images/2020/11/image.png" alt="PBK Snippet" /></a></p>

<p>Alright, we’ve deployed the VPN - but it still isn’t automatically connecting. Let’s go and figure that out.</p>

<p>The key to this solution is found in the registry (as always). The auto connection settings can be found in the local machine hive path shown below.</p>

<p><strong>HKLM:\SYSTEM\CurrentControlSet\Services\RasMan\Config</strong></p>

<p><a href="/assets/images/2020/11/image-1.png" title="VPN Registry"><img src="/assets/images/2020/11/image-1.png" alt="VPN Registry" /></a></p>

<p>As you can see above, for my corporate VPN connection, we are setting a few key values - namely:</p>

<ul>
  <li><strong>AutoTriggerDisabledProfilesList</strong> - A list of VPNs specifically set to not automatically connect (done manually by the user).</li>
  <li><strong>AutoTriggerProfileEntryName</strong> - The Name of the VPN connection</li>
  <li><strong>AutoTriggerProfileGUID</strong> - The HEX GUID of the VPN connection</li>
  <li><strong>AutoTriggerProfilePhonebookPath</strong> - The path to the phonebook file</li>
  <li><strong>UserSID</strong> - The SID of the user who has set the automatic connection.</li>
</ul>

<p>Once we understand what is required to set the connection, all we need to do is fill out the data and store it in the correct registry location!</p>

<pre class="wp-block-code" title="Connect Automatically"><code lang="powershell" class="language-powershell line-numbers">
#region Functions
function Convert-HexToByte {
  [cmdletbinding()]
  param (
    [string]$HexString
  )
  $splitString = ($HexString -replace '(..)','$1,').Trim(',')
  [byte[]]$hexified = $splitString.Split(',') | ForEach-Object { "0x$_"}
  return $hexified
}
function Set-ComputerRegistryValues {
  param (
      [Parameter(Mandatory = $true)]
      [array]$RegistryInstance
  )
  try {
      foreach ($key in $RegistryInstance) {
          $keyPath = $key.Path
          if (!(Test-Path $keyPath)) {
              Write-Host "Registry path : $keyPath not found. Creating now." -ForegroundColor Green
              New-Item -Path $key.Path -Force | Out-Null
              Write-Host "Creating item property: $($key.Name)" -ForegroundColor Green
              New-ItemProperty -Path $keyPath -Name $key.Name -Value $key.Value -Type $key.Type -Force
          }
          else {
              Write-Host "Creating item property: $($key.Name)" -ForegroundColor Green
              New-ItemProperty -Path $keyPath -Name $key.Name -Value $key.Value -Type $key.Type -Force
          }
      }
  }
  catch {
      Throw $_.Exception.Message
  }
}
#endregion
#region Configure Always On
[string[]]$autoDisable = (Get-ItemPropertyValue $rasManKeyPath -Name AutoTriggerDisabledProfilesList) | ForEach-Object { if ($_ -ne $VPNName) { $_ }}
$regKeys = @(
  @{
    Path = $rasManKeyPath
    Name = 'AutoTriggerDisabledProfilesList'
    Value = [string[]]$autoDisable
    Type = 'MultiString'
  }
  @{
    Path = $rasManKeyPath
    Name = 'AutoTriggerProfilePhonebookPath'
    Value = "$RequiredFolder\rasphone.pbk"
    Type = 'String'
  }
  @{
    Path = $rasManKeyPath
    Name = 'AutoTriggerProfileEntryName'
    Value = $VPNName
    Type = 'String'
  }
@{
    Path = $rasManKeyPath
    Name = 'UserSID'
    Value = $sid
    Type = 'String'
  }
@{
    Path = $rasManKeyPath
    Name = 'AutoTriggerProfileGUID'
    Value = [Byte[]](Convert-HexToByte -HexString $VPNGUID)
    Type = 'Binary'
  }
)
Set-ComputerRegistryValues $regKeys
#endregion</code></pre>

<p>Again, most of this code is quite simple - all we are doing is entering some data into the registry.</p>

<p>The only interesting thing of interest is how I’m converting the VPN GUID from the phonebook file into the Binary format required - which is done with the function <strong>Convert-HexToByte</strong> show above - that took me a little longer than I’m willing to admit!</p>

<p>The other thing to be aware of is that deploying the VPN config can be done either in the User or System context - no admin privileges are required, however due to the registry keys being stored in the HKLM hive, admin privileges will be required to set the “connect automatically” section of this solution.</p>

<p>That’s it for now - if you’ve got any questions about this solution, please reach out to me on <a href="https://twitter.com/powers_hell">twitter</a>, and as always, the code for this post can be found on my <a href="https://github.com/tabs-not-spaces/CodeDump/tree/master/AzureVPNAutoConnect">GitHub</a>.</p>

<p>— Ben</p>]]></content><author><name>Ben</name></author><category term="Azure" /><category term="Intune" /><category term="PowerShell" /><category term="Intune" /><summary type="html"><![CDATA[One of my clients recently came to me asking for assistance to set up a new VPN solution. The requirements were quite simple - They were building out an Azure Point-To-Site VPN solution and needed me to come up with a way to deliver the connection to the end user devices.]]></summary></entry></feed>