<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator><link href="https://powers-hell.com/feed.xml" rel="self" type="application/atom+xml" /><link href="https://powers-hell.com/" rel="alternate" type="text/html" /><updated>2021-07-20T02:09:34+00:00</updated><id>https://powers-hell.com/feed.xml</id><title type="html">Powers Hell</title><subtitle>great/power/is/great/fun &gt;</subtitle><entry><title type="html">Authenticating to Microsoft Graph with PowerShell - (2021)</title><link href="https://powers-hell.com/2021/07/18/authenticating-to-microsoft-graph-with-powershell-(2021)/" rel="alternate" type="text/html" title="Authenticating to Microsoft Graph with PowerShell - (2021)" /><published>2021-07-18T05:37:00+00:00</published><updated>2021-07-18T05:37:00+00:00</updated><id>https://powers-hell.com/2021/07/18/authenticating-to-microsoft-graph-with-powershell-(2021)</id><content type="html" xml:base="https://powers-hell.com/2021/07/18/authenticating-to-microsoft-graph-with-powershell-(2021)/">&lt;p&gt;Talking about ways to authenticate to Graph is one of my least favourite subjects. After a while it gets a bit monotonous, but as with all technologies, things change..&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;So Iâ€™ve decided to try something out - once a year, Iâ€™m going to write a revised guide to the BEST ways to authenticate using PowerShell (in my opinion) and make mention of any new notable advances within the space (if there are any!).&lt;/p&gt;

&lt;p&gt;Alright, with the intro out of the way, letâ€™s dive in.&lt;/p&gt;

&lt;h2 id=&quot;quick-primer&quot;&gt;Quick Primer&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/graph/overview&quot;&gt;Microsoft Graph&lt;/a&gt;, for those living under a rock, is the underlying API that unifys Microsoft 365, Windows 10 &amp;amp; Enterprise Mobility + Security, so that all we need to learn is a &lt;strong&gt;single REST API&lt;/strong&gt; to give us programmatic access to read and interact with the data within those product ecosystems.&lt;/p&gt;

&lt;p&gt;To work with Graph, the first and foremost thing we need to do is authenticate into the service. Using PowerShell makes this SIMPLE.&lt;/p&gt;

&lt;h2 id=&quot;how-do-i-authenticate&quot;&gt;How do I authenticate?&lt;/h2&gt;

&lt;p&gt;Authentication is surprisingly easy, once you understand the underlying concepts.&lt;/p&gt;

&lt;p&gt;At a high level, all we are doing is providing some form of proof that we are allowed access to the Graph data in our Azure tenant. We do this using an authentication technology called &lt;a href=&quot;https://oauth.net/2/&quot;&gt;OAuth 2.0&lt;/a&gt;. There are two primary methods of authentication:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Interactive, or delegated authentication. This allows us to authenticate to Graph utilizing our Azure AD account / password. This generally assumes an interactive experience, meaning you are probably running a script locally, or using a tool on your computer.&lt;/li&gt;
  &lt;li&gt;Programmatic, or application authentication. This allows us to authenticate to Graph utilizing the credentials of an application registered in AAD. This allows us to securely authenticate to Graph without requiring user interaction, is not tied to a specific user account and access is controlled via the app registrations portal of AAD.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Regardless of what method you choose to authenticate to Graph, the process is essentially the same and can actually be done very quickly / simply by just correctly forming and sending a HTTP request to the OAuth endpoint. &lt;a href=&quot;/2018/08/17/authenticate-to-microsoft-graph-in-powershell-in-two-lines-of-code/&quot;&gt;Iâ€™ve discussed this previously&lt;/a&gt;, and not much has changed since that article. Below shows how to authenticate both Interactively &amp;amp; Programmatically using nothing but PowerShell.&lt;/p&gt;

&lt;h3 id=&quot;interactive-authentication&quot;&gt;Interactive authentication&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-PowerShell&quot;&gt;$tenantId = 'powers-hell.com'
$requestBody = @{
    resource   = 'https://graph.microsoft.com'
    client_id  = 'd1ddf0e4-d672-4dae-b554-9d5bdfd93547'
    grant_type = &quot;password&quot;
    username   = 'ben@powers-hell.com'
    scope      = &quot;openid&quot;
    password   = 'MySuperSecetPassword'
}
$auth = Invoke-RestMethod -Method post -Uri &quot;https://login.microsoftonline.com/$tenantId/oauth2/token&quot; -Body $body
$auth
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;programmatic-authentication&quot;&gt;Programmatic authentication&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-PowerShell&quot;&gt;$tenantId = 'powers-hell.com'
$reqestBody = @{
    resource      = 'https://graph.microsoft.com'
    client_id     = 'd1ddf0e4-d672-4dae-b554-9d5bdfd93547'
    client_secret = $client_secret
    grant_type    = &quot;client_credentials&quot;
    scope         = &quot;openid&quot;
}
$auth = Invoke-RestMethod -Method post -Uri &quot;https://login.microsoftonline.com/$tenantId/oauth2/token&quot; -Body $body
$auth
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you should be able to tell from both of those examples, they are almost identical, the only difference is the &lt;strong&gt;grant_type&lt;/strong&gt; property, which simple tells the OAuth endpoint what to do with the credential payload we are sending along.&lt;/p&gt;

&lt;p&gt;Both of these examples are very simple, but will work for most scenarios - with the key caveat being that you will not be able to handle MFA if your AAD tenant is configured to require it (for interactive authentication only.)&lt;/p&gt;

&lt;p&gt;The good news is we can leverage existing authentication libraries provided by Microsoft to overcome these problems, as well as improving error handling and allowing for future changes to the authentication process.&lt;/p&gt;

&lt;h2 id=&quot;msal-adal-what-are-these-acronyms-and-what-do-i-do-with-them&quot;&gt;MSAL? ADAL? What are these acronyms and what do I do with them?&lt;/h2&gt;

&lt;p&gt;While we can manually build our authentication requests and send them to the OAuth endpoint, we should probably leverage the libraries created by Microsoft to make this experiences more reliable and easier.&lt;/p&gt;

&lt;p&gt;To that end, Microsoft has built two authentication libraries over the years, the Active Directory Authentication Library (ADAL) and the Microsoft Authentication Library (MSAL).&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;drac-text-yellow-pink drac-text-bold drac-text-lg&quot;&gt;
!! DO NOT USE ADAL FOR AUTHENTICATION !!
&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;If the only thing you take away from the article is the following line, then I feel I have done my job. Microsoft has announced &lt;a href=&quot;https://techcommunity.microsoft.com/t5/azure-active-directory-identity/update-your-applications-to-use-microsoft-authentication-library/ba-p/1257363&quot;&gt;&lt;strong&gt;end of support timelines&lt;/strong&gt; for ADAL&lt;/a&gt;, and no further feature development will take place on the library.&lt;/p&gt;

&lt;p&gt;Now that we have that out of the way, what does that mean? It means all we need to talk about is MSAL!&lt;/p&gt;

&lt;h2 id=&quot;authenticating-with-msalps&quot;&gt;Authenticating with MSAL.PS&lt;/h2&gt;

&lt;p&gt;By and far the EASIEST way to implement Graph authentication in your PowerShell solution is to leverage the excellent Module &lt;a href=&quot;https://www.powershellgallery.com/packages/MSAL.PS/&quot;&gt;&lt;strong&gt;MSAL.PS&lt;/strong&gt;&lt;/a&gt;. &lt;a href=&quot;/2020/06/28/managing-intune-with-graph-powershell-7-msal/&quot;&gt;Iâ€™ve already spoken about how to use this module&lt;/a&gt;, but to keep everything central, letâ€™s go through it now.&lt;/p&gt;

&lt;p&gt;First, letâ€™s install the module&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-PowerShell&quot;&gt;Install-Module MSAL.PS
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now letâ€™s authenticate.&lt;/p&gt;

&lt;h3 id=&quot;interactive-authentication-1&quot;&gt;Interactive authentication&lt;/h3&gt;

&lt;p&gt;Assuming your AAD application has been setup correctly to work with MSAL (at minimum just make sure thereâ€™s a reply URL set to &lt;strong&gt;http://localhost&lt;/strong&gt;) then we can use this code.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-PowerShell&quot;&gt;$authParams = @{
    ClientId    = 'd1ddf0e4-d672-4dae-b554-9d5bdfd93547'
    TenantId    = 'power-hell.com'
    Interactive = $true
}
$auth = Get-MsalToken @authParams
$auth
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If it hasnâ€™t - or you down own the AAD application and just need to use it interactively (specifically in PowerShell 7), then utilizing the DeviceCode auth flow will be required.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-PowerShell&quot;&gt;$authParams = @{
    ClientId    = 'd1ddf0e4-d672-4dae-b554-9d5bdfd93547'
    TenantId    = 'powers-hell.com'
    DeviceCode  = $true
}
$auth = Get-MsalToken @authParams
$auth
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;programmatic-authentication-1&quot;&gt;Programmatic authentication&lt;/h3&gt;

&lt;p&gt;This one is simple!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-PowerShell&quot;&gt;$authparams = @{
    ClientId     = 'd1ddf0e4-d672-4dae-b554-9d5bdfd93547'
    TenantId     = 'powers-hell.com'
    ClientSecret = ('MySuperSecretClientSecret' | ConvertTo-SecureString -AsPlainText -Force)
}
$auth = Get-MsalToken @authParams
$auth
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As is hopefully evident, the only tricky thing to remember here is you need to convert your client secret to a secure string type before sending it to the command.&lt;/p&gt;

&lt;h2 id=&quot;ok-ive-got-my-auth-token-now-what&quot;&gt;Ok Iâ€™ve got my auth token. Now what?&lt;/h2&gt;

&lt;p&gt;As you can see, there are many ways to authenticate to Graph. But if you donâ€™t use it, why did we even bother?&lt;/p&gt;

&lt;p&gt;The most important thing to understand is that within the returned authentication object in &lt;strong&gt;any&lt;/strong&gt; of the above examples will be the &lt;strong&gt;access token&lt;/strong&gt;. With that, we need to build an &lt;em&gt;Authorization&lt;/em&gt; object to send along with all of our call to Graph. Luckily, this is super easy!&lt;/p&gt;

&lt;p&gt;Below is a few examples of how to generate the authorization object to pull back a list of users from Graph.&lt;/p&gt;

&lt;h3 id=&quot;without-libraries-aka-the-manual-way&quot;&gt;Without libraries (AKA the Manual way)&lt;/h3&gt;

&lt;h5 id=&quot;powershell-5--7&quot;&gt;PowerShell 5 &amp;amp; 7&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&quot;language-PowerShell&quot;&gt;$authorizationHeader = @{
    Authorization = &quot;Bearer $($auth.access_token)&quot;
}
$requestBody = @{
    Method      = 'Get'
    Uri         = 'https://graph.microsoft.com/v1.0/users'
    Headers     = $authorizationHeader
    ContentType = 'Application/Json'
}
$response = Invoke-RestMethod @requestBody
$response
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&quot;powershell-7-only-aka-the-new-method&quot;&gt;PowerShell 7 ONLY (AKA the new method)&lt;/h5&gt;

&lt;p&gt;This method is relatively new &amp;amp; only works in PowerShell 7. Instead of creating the authorization header manually, we can get the Invoke-RestMethod to build it for us!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-PowerShell&quot;&gt;$requestBody = @{
    Method          = 'Get'
    Uri             = 'https://graph.microsoft.com/v1.0/users'
    Authentication  = 'OAuth'
    Token           = ($auth.access_token | ConvertTo-SecureString -AsPlainText -Force)
    ContentType     = 'Application/Json'
}
$response = Invoke-RestMethod @requestBody
$response
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see, this is a bit cleaner - all we need to do is define that the token was derived from an OAuth request, and then convert the access token to a secure string.&lt;/p&gt;

&lt;h3 id=&quot;with-msal&quot;&gt;With MSAL&lt;/h3&gt;

&lt;h5 id=&quot;powershell-5--7-1&quot;&gt;PowerShell 5 &amp;amp; 7&lt;/h5&gt;

&lt;p&gt;The MSAL.PS module exposes some of the methods within the libraries to help us build the authorization header - if you find typing things difficult..&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-PowerShell&quot;&gt;$authorizationHeader = @{
    Authorization = $auth.CreateAuthorizationHeader()
}
$requestBody = @{
    Method      = 'Get'
    Uri         = 'https://graph.microsoft.com/v1.0/users'
    Headers     = $authorizationHeader
    ContentType = 'Application/Json'
}
$response = Invoke-RestMethod @requestBody
$response
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&quot;powershell-7-only-aka-the-new-method-1&quot;&gt;PowerShell 7 ONLY (AKA the new method)&lt;/h5&gt;

&lt;p&gt;And finally, for completeness, we can use the new Invoke-RestMethod parameters with MSAL to really show off. The only thing to note of difference here is that the &lt;em&gt;access token&lt;/em&gt; property returned from the MSAL call is named &lt;strong&gt;AccessToken&lt;/strong&gt; compared to the native HTTP request which is &lt;strong&gt;Access_Token&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-PowerShell&quot;&gt;$requestBody = @{
    Method          = 'Get'
    Uri             = 'https://graph.microsoft.com/v1.0/users'
    Authentication  = 'OAuth'
    Token           = ($auth.AccessToken | ConvertTo-SecureString -AsPlainText -Force)
    ContentType     = 'Application/Json'
}
$response = Invoke-RestMethod @requestBody
$response
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And there it is - Authentication to Graph with PowerShell in 2021. If you learned anything from this article, please feel free to share it and let me know via &lt;a href=&quot;https://twitter.com/powers_hell&quot;&gt;twitter&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Hopefully thatâ€™s the last time I need to speak about authentication for another year!&lt;/p&gt;

&lt;p&gt;â€” Ben&lt;/p&gt;</content><author><name>Ben</name></author><category term="PowerShell" /><category term="Graph" /><category term="ADAL IS DEAD" /><category term="Authentication" /><category term="PowerShell" /><category term="Graph" /><category term="ADAL IS DEAD" /><category term="Authentication" /><summary type="html">Talking about ways to authenticate to Graph is one of my least favourite subjects. After a while it gets a bit monotonous, but as with all technologies, things change..</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://powers-hell.com/assets/images/2021/07/msal-authentication-2021.gif" /><media:content medium="image" url="https://powers-hell.com/assets/images/2021/07/msal-authentication-2021.gif" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Create &amp;amp; assign filters with PowerShell &amp;amp; Graph</title><link href="https://powers-hell.com/2021/07/04/create-assign-filters-with-powershell-graph/" rel="alternate" type="text/html" title="Create &amp;amp; assign filters with PowerShell &amp;amp; Graph" /><published>2021-07-04T02:17:00+00:00</published><updated>2021-07-04T02:17:00+00:00</updated><id>https://powers-hell.com/2021/07/04/create-assign-filters-with-powershell-graph</id><content type="html" xml:base="https://powers-hell.com/2021/07/04/create-assign-filters-with-powershell-graph/">&lt;p&gt;As Iâ€™ve said before, working with dynamic groups in Intune &lt;a href=&quot;/2021/06/16/create-advanced-dynamic-groups-with-powershell-azure-functions/&quot;&gt;isnâ€™t my favourite thing&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Luckily, Microsoft has been listening and have provided us with a better way to dynamically apply policies to devices with &lt;a href=&quot;https://docs.microsoft.com/en-us/mem/intune/fundamentals/filters&quot;&gt;filters!&lt;/a&gt;&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;I recently sat down with &lt;a href=&quot;https://twitter.com/scottduf&quot;&gt;Scott Duffey&lt;/a&gt; (who brought us this amazing new feature) to dive into how filters work and how they can improve our endpoint management workflows.&lt;/p&gt;

&lt;div class=&quot;video-container&quot;&gt;
&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/_UuMfbvY8hw&quot; title=&quot;YouTube video player&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; clipboard-write; encrypted-media;&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;p&gt;As is always the case, after finishing our chat, I immediately wanted to figure out how to work with Filters in a more programmatic way. Turns out, it was super easy!&lt;/p&gt;

&lt;h2 id=&quot;overview&quot;&gt;Overview&lt;/h2&gt;

&lt;p&gt;At a high level, what makes filters so much better for use in Intune comes down to two primary factors.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;The filter evaluation is done when the device enrolls, checks in with the Intune service or basically any time a policy is evaluated - which means the speed of evaluation is &lt;em&gt;significantly&lt;/em&gt; faster than that of dynamic groups.&lt;/li&gt;
  &lt;li&gt;Filters are decoupled from groups, which means they are now &lt;strong&gt;reusable&lt;/strong&gt;. This means we can now create &lt;strong&gt;one&lt;/strong&gt; filter and use it for &lt;strong&gt;many&lt;/strong&gt; policies!&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;So letâ€™s get started and create our first filter.&lt;/p&gt;

&lt;h2 id=&quot;create-a-filter&quot;&gt;Create a filter&lt;/h2&gt;

&lt;h5 id=&quot;authenticate&quot;&gt;Authenticate&lt;/h5&gt;

&lt;p&gt;As we are using PowerShell &amp;amp; Graph, we will need to authenticate.&lt;/p&gt;

&lt;p&gt;Using the MSAL.PS module makes this easy.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-PowerShell&quot;&gt;$authParams = @{
    ClientId    = 'd1ddf0e4-d672-4dae-b554-9d5bdfd93547'
    TenantId    = 'powers-hell.com'
    DeviceCode  = $true
}
$authToken = Get-MsalToken @authParams
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&quot;build-and-post&quot;&gt;Build and post&lt;/h5&gt;

&lt;p&gt;Now we need to build out a new filter object to post to Graph. This is just a simple json object that we will publish to the &lt;strong&gt;assignedFilters&lt;/strong&gt; endpoint.&lt;/p&gt;

&lt;p&gt;For this example we want a filter that finds all corporate owned virtual machines.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-PowerShell&quot;&gt;$filter = @{
    displayName = 'Example Filter'
    description = 'This filter will select all virtual machines'
    platform    = 'Windows10AndLater'
    rule        = '(device.deviceOwnership -eq &quot;Corporate&quot;) and (device.model -startsWith &quot;Virtual Machine&quot;)'
} | ConvertTo-Json -Depth 10
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As you can see from above, the actual request body is quite simple. The actual filter rule uses the same syntax and formatting as dynamic rules, so the learning curve is quite low.&lt;/p&gt;

&lt;p&gt;Now lets post our filter to graph.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-PowerShell&quot;&gt;$baseGraphUri = 'https://graph.microsoft.com/beta/deviceManagement/assignmentFilters'
$graphParams = @{
    Method          = 'Post'
    Uri             = $baseGraphUri
    Authentication  = 'OAuth'
    Token           = $authToken.AccessToken | ConvertTo-SecureString -AsPlainText -Force
    ContentType     = 'Application/Json'
    Body            = $filter
}
Invoke-RestMethod @graphParams
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If successful, we should see the results of the post sent back to us. Make note of the returned id, and letâ€™s move on!&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/2021/07/image1.gif&quot; title=&quot;Successful filter post&quot;&gt;&lt;img src=&quot;/assets/images/2021/07/image1.gif&quot; alt=&quot;Successful filter post&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;assign-a-filter&quot;&gt;Assign a filter&lt;/h2&gt;

&lt;p&gt;Now that weâ€™ve got our filter created, letâ€™s assign it to a policy. In this example, Iâ€™ve got an application I want to deploy (as required) to all of my virtual machines. To make sure I capture all possible virtual machines, Iâ€™ll assign the application to &lt;strong&gt;all devices&lt;/strong&gt; and then filter down to the virtual machines using the filter object weâ€™ve already created.&lt;/p&gt;

&lt;p&gt;The first most obvious thing we need to do is know what the id of the policy is that we want. The easiest way to get that is to simply go to the policy in the endpoint portal.&lt;/p&gt;

&lt;p&gt;Once youâ€™ve got both the policy id and the filter id (from the creation steps above) , all that we need to do is build another post request to graph.&lt;/p&gt;

&lt;p&gt;First, letâ€™s build the body of the post.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-PowerShell&quot;&gt;$filterId = '2727f0f4-d030-4792-8aba-b6ef5efe602d' #your filter id
$assignments = @{
    mobileAppAssignments = @(
        @{
            '@odata.type' = '#microsoft.graph.mobileAppAssignment'
            intent        = 'Required'
            target        = @{
                '@odata.type'                              = '#microsoft.graph.allDevicesAssignmentTarget'
                deviceAndAppManagementAssignmentFilterId   = $filterId
                deviceAndAppManagementAssignmentFilterType = 'include'
            }
        }
    )
} | ConvertTo-Json -Depth 10
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is a &lt;em&gt;little&lt;/em&gt; more complicated that the previous request we built, but only because we are dealing with nested objects. Simply speaking, all we are doing is creting a new &lt;strong&gt;required&lt;/strong&gt; assignment pointing at the &lt;strong&gt;microsoft.graph.allDevicesAssignmentTarget&lt;/strong&gt; object, and &lt;strong&gt;including&lt;/strong&gt; our filter as part of the assignment.&lt;/p&gt;

&lt;p&gt;If you were to replicate this experience, but use your own security groups, youâ€™d simply change the target &lt;strong&gt;odata.type&lt;/strong&gt; to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;microsoft.graph.groupAssignmentTarget&lt;/code&gt; and add a &lt;strong&gt;groupId&lt;/strong&gt; property underneath it, as shown below.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-PowerShell&quot;&gt;$filterId = '2727f0f4-d030-4792-8aba-b6ef5efe602d' #your filter id
$groupId = 'da630732-10ac-47ae-94f9-2e5b9042109c' #your group id
$assignments = @{
    mobileAppAssignments = @(
        @{
            '@odata.type' = '#microsoft.graph.mobileAppAssignment'
            intent        = 'Required'
            target        = @{
                '@odata.type'                              = '#microsoft.graph.groupAssignmentTarget',
                groupId                                    = $groupId,
                deviceAndAppManagementAssignmentFilterId   = $filterId
                deviceAndAppManagementAssignmentFilterType = 'include'
            }
        }
    )
} | ConvertTo-Json -Depth 10
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Similarly, if you wanted to &lt;strong&gt;exclude&lt;/strong&gt; the objects captured in the filter group, change the &lt;strong&gt;deviceAndAppManagementAssignmentFilterType&lt;/strong&gt; property to &lt;strong&gt;exclude&lt;/strong&gt; - amazing, isnâ€™t it!&lt;/p&gt;

&lt;p&gt;Now that we have our request body formed, letâ€™s post it to our policy.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-PowerShell&quot;&gt;$policyId = '149bf3d2-56cf-4cda-a3ea-79b6adb1c638' #your application policy id
$baseGraphUri = 'https://graph.microsoft.com/beta/deviceAppManagement/mobileApps/{0}/assign' -f $policyId
$graphParams = @{
    Method         = 'Post'
    Uri            = $baseGraphUri
    Authentication = 'OAuth'
    Token          = $authToken.AccessToken | ConvertTo-SecureString -AsPlainText -Force
    ContentType    = 'Application/Json'
    Body           = $assignments
}
Invoke-RestMethod @graphParams
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Post requests to the assign endpoint donâ€™t return anything back to us, but as long as we donâ€™t get any errors, we should be good to go.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/2021/07/image2.gif&quot; title=&quot;Successful assignment&quot;&gt;&lt;img src=&quot;/assets/images/2021/07/image2.gif&quot; alt=&quot;Successful assignment&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;How simple is that!&lt;/p&gt;

&lt;p&gt;Now, thanks to filters, you can start scoping policies and applications to larger groups, and use filters to tighten up the scope in a simple reusable fashion.&lt;/p&gt;

&lt;p&gt;â€” Ben&lt;/p&gt;</content><author><name>Ben</name></author><category term="PowerShell" /><category term="Automation" /><category term="Graph" /><category term="Intune" /><category term="PowerShell" /><category term="Automation" /><category term="Graph" /><category term="Intune" /><summary type="html">As Iâ€™ve said before, working with dynamic groups in Intune isnâ€™t my favourite thing. Luckily, Microsoft has been listening and have provided us with a better way to dynamically apply policies to devices with filters!</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://powers-hell.com/assets/images/2021/07/image2.gif" /><media:content medium="image" url="https://powers-hell.com/assets/images/2021/07/image2.gif" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Create advanced dynamic groups with PowerShell &amp;amp; Azure Functions</title><link href="https://powers-hell.com/2021/06/16/create-advanced-dynamic-groups-with-powershell-azure-functions/" rel="alternate" type="text/html" title="Create advanced dynamic groups with PowerShell &amp;amp; Azure Functions" /><published>2021-06-16T06:56:00+00:00</published><updated>2021-06-16T06:56:00+00:00</updated><id>https://powers-hell.com/2021/06/16/create-advanced-dynamic-groups-with-powershell-azure-functions</id><content type="html" xml:base="https://powers-hell.com/2021/06/16/create-advanced-dynamic-groups-with-powershell-azure-functions/">&lt;p&gt;Iâ€™ve never been entirely happy with dynamic groups in Intune. The primary reason for this boils down to two primary issues:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The time it takes to analyze the dynamic group rules is nowhere near fast enough.&lt;/li&gt;
  &lt;li&gt;The available properties available for dynamic group rules are limited to the data available in AAD - not Intune.&lt;/li&gt;
&lt;/ul&gt;

&lt;!--more--&gt;

&lt;p&gt;While the first issue has been remediated with the introduction of &lt;a href=&quot;https://docs.microsoft.com/en-us/mem/intune/fundamentals/filters&quot;&gt;filters&lt;/a&gt;, the fact that I canâ€™t create a rule on ANY property I want still bugs me.&lt;/p&gt;

&lt;p&gt;I recently sat down with my good friend &lt;a href=&quot;https://twitter.com/OnPremCloudGuy&quot;&gt;Steven Hosking&lt;/a&gt; and discussed ways to create dynamic groups using Power Automate, proving that with a little bit of effort (and deep-diving into Graph), you can build dynamic groups using custom logic. Check out the video below.&lt;/p&gt;

&lt;div class=&quot;video-container&quot;&gt;
    &lt;iframe src=&quot;https://www.youtube.com/embed/OLIA5_YW0Pg&quot; title=&quot;S02E36 - Building Custom Dynamic Groups with Power Automate - (I.T)&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; clipboard-write; encrypted-media;&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;p&gt;Now that we know how &lt;em&gt;relatively simple&lt;/em&gt; it is to build out custom dynamic groups with Power Automate, Letâ€™s look into how we can achieve the same result with nothing but PowerShell &amp;amp; Azure Functions.&lt;/p&gt;

&lt;h2 id=&quot;overview&quot;&gt;Overview&lt;/h2&gt;

&lt;p&gt;Like the video above, we can make sure that compliant devices are members of a specific security group. If they are no longer compliant, we want to make sure they are removed.&lt;/p&gt;

&lt;p&gt;The solution we will build has two core elements:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;An AAD application configured with &lt;strong&gt;application-scoped&lt;/strong&gt; API permissions.&lt;/li&gt;
  &lt;li&gt;An Azure function app to handle the group membership logic.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;aad-application&quot;&gt;AAD application&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/azure/active-directory/develop/quickstart-register-app&quot;&gt;Create an AAD application&lt;/a&gt; with the following API permissions:&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;API Permission Name&lt;/th&gt;
      &lt;th&gt;Type&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Device.Read.All&lt;/td&gt;
      &lt;td&gt;Application&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;DeviceManagementManagedDevices.Read.All&lt;/td&gt;
      &lt;td&gt;Application&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Group.Read.All&lt;/td&gt;
      &lt;td&gt;Application&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;GroupMember.ReadWrite.All&lt;/td&gt;
      &lt;td&gt;Application&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;Grant admin consent for the above permissions.&lt;/li&gt;
  &lt;li&gt;Generate a &lt;strong&gt;client secret&lt;/strong&gt; and store it, along with the &lt;strong&gt;application ID&lt;/strong&gt; for future use.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;function-application&quot;&gt;Function application&lt;/h2&gt;

&lt;p&gt;Create a &lt;strong&gt;consumption&lt;/strong&gt; function app (either in the &lt;a href=&quot;https://docs.microsoft.com/en-us/azure/azure-functions/functions-create-function-app-portal&quot;&gt;Azure portal&lt;/a&gt;, or &lt;a href=&quot;https://docs.microsoft.com/en-us/azure/azure-functions/create-first-function-vs-code-powershell&quot;&gt;VSCode&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/2021/06/functionapp.png&quot; title=&quot;Basic function app creation&quot;&gt;&lt;img src=&quot;/assets/images/2021/06/functionapp.png&quot; alt=&quot;Basic function app creation&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;From here on out, Iâ€™ll be sharing screens from VSCode, but you can achieve the same results directly from the portal as well.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/2021/06/pwsh_001.gif&quot; title=&quot;Function app creation in VSCode&quot;&gt;&lt;img src=&quot;/assets/images/2021/06/pwsh_001.gif&quot; alt=&quot;Function app creation in VSCode&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;Tip:&lt;/strong&gt; Because this function app doesnâ€™t rely on any external modules, we can speed up its &lt;strong&gt;cold-start&lt;/strong&gt; performance by setting &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;managedDependency enabled&lt;/code&gt; value to &lt;strong&gt;false&lt;/strong&gt; in the host.json file.
&lt;a href=&quot;/assets/images/2021/06/pwsh_002.png&quot; title=&quot;disable managed dependency for faster cold start times&quot;&gt;&lt;img src=&quot;/assets/images/2021/06/pwsh_002.png&quot; alt=&quot;disable managed dependency for faster cold start times&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Once you have your function app created, we will need to set up the following application variables:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Variable Name&lt;/th&gt;
      &lt;th&gt;Variable Value&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;TENANT_ID&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;Your tenant ID \ AAD domain name&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;APPLICATION_ID&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;Your AAD application ID&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;CLIENT_SECRET&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;Your AAD application client secret&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;GROUP_ID&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;The object id of the security group you want to manage&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;For those who want to build this locally, you can put the above variables in your &lt;strong&gt;local.settings.json&lt;/strong&gt; file within your function app project.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/2021/06/pwsh_004.png&quot; title=&quot;local.settings.json&quot;&gt;&lt;img src=&quot;/assets/images/2021/06/pwsh_004.png&quot; alt=&quot;local.settings.json&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Now comes the fun part. Writing the function app logic. The script can be broken down into three main parts:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Authentication&lt;/li&gt;
  &lt;li&gt;Getting compliance data with Graph&lt;/li&gt;
  &lt;li&gt;Adding / Deleting group memberships with Graph&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Letâ€™s look at each section now.&lt;/p&gt;

&lt;h3 id=&quot;authentication&quot;&gt;Authentication&lt;/h3&gt;

&lt;p&gt;Nothing super fancy here - Iâ€™ve discussed the ways to authenticate to Graph many times before. We will leverage the app variables we set up earlier to authenticate to our AAD application and store the token for the next few steps of the solution.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-PowerShell&quot;&gt;function Get-AuthHeader {
    param (
        [Parameter(mandatory = $true)]
        [string]$TenantId,
        [Parameter(mandatory = $true)]
        [string]$ClientId,
        [Parameter(mandatory = $true)]
        [string]$ClientSecret,
        [Parameter(mandatory = $true)]
        [string]$ResourceUrl
    )
    $body = @{
        resource      = $ResourceUrl
        client_id     = $ClientId
        client_secret = $ClientSecret
        grant_type    = &quot;client_credentials&quot;
        scope         = &quot;openid&quot;
    }
    try {
        $response = Invoke-RestMethod -Method post -Uri &quot;https://login.microsoftonline.com/$TenantId/oauth2/token&quot; -Body $body -ErrorAction Stop
        $headers = @{ &quot;Authorization&quot; = &quot;Bearer $($response.access_token)&quot; }
        return $headers
    }
    catch {
        Write-Error $_.Exception
    }
}
$params = @{
    TenantId     = $env:TENANT_ID
    ClientId     = $env:CLIENT_ID
    ClientSecret = $env:CLIENT_SECRET
    ResourceUrl  = &quot;https://graph.microsoft.com&quot;
}
$authHeader = Get-AuthHeader @params
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;compliance-validation&quot;&gt;Compliance validation&lt;/h3&gt;

&lt;p&gt;Now that we have authenticated into Graph letâ€™s grab all the devices and check their compliance state.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-PowerShell&quot;&gt;$graphUri = 'https://graph.microsoft.com/Beta/deviceManagement/managedDevices'
$params = @{
    Method      = 'Get'
    Headers     = $authHeader
    Uri         = $graphUri
    ContentType = 'Application/Json'
}
$query = Invoke-RestMethod @params
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The results of the query are now stored in the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$query&lt;/code&gt; variable. If we dive into the returned object data, selecting only the properties we want to see, we should start seeing some usable data.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-PowerShell&quot;&gt;$query.Value | Select-Object deviceName, complianceState
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/2021/06/pwsh_003.gif&quot; title=&quot;results of our first Graph query&quot;&gt;&lt;img src=&quot;/assets/images/2021/06/pwsh_003.gif&quot; alt=&quot;results of our first Graph query&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Now we know how to capture the compliance state of our devices, we can move onto managing their group memberships!&lt;/p&gt;

&lt;h3 id=&quot;managing-group-memberships&quot;&gt;Managing group memberships&lt;/h3&gt;

&lt;p&gt;Because security groups in Azure are an &lt;em&gt;AAD thing&lt;/em&gt; we need to trade the Intune device object we got in the previous code snippet for the AAD device object. Luckily, the Intune object above contains the &lt;strong&gt;azureADDeviceId&lt;/strong&gt; property, so itâ€™s easy to get what we need. Letâ€™s see how we would get the AAD object of just one of the devices in the returned objects.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-PowerShell&quot;&gt;$firstDevice = $query.Value[0]
$graphUri = &quot;https://graph.microsoft.com/beta/devices?`$filter=deviceId eq '$($firstDevice.azureADDeviceId)'&quot;
$params = @{
    Method      = 'Get'
    Headers     = $authHeader
    Uri         = $graphUri
    ContentType = 'Application/Json'
}
$AADDevice = Invoke-RestMethod @params
$AADDevice.Value
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now letâ€™s get the current group members of the security group we want to manage.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-PowerShell&quot;&gt;$graphUri = &quot;https://graph.microsoft.com/beta/groups/$env:GROUP_ID/members&quot;
$params = @{
    Method      = 'Get'
    Headers     = $authHeader
    Uri         = $graphUri
    ContentType = 'Application/Json'
}
$groupMembers = Invoke-RestMethod @params
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Letâ€™s check if the device is already a member - if itâ€™s not and the &lt;strong&gt;complianceState&lt;/strong&gt; value is true, letâ€™s add it.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-PowerShell&quot;&gt;if ($firstDevice.complianceState -eq &quot;Compliant&quot;) {
    if ($groupMembers.value -notcontains $AADDevice.value[0].deviceId) {
        #region Device is compliant and not in the group
        $graphUri = &quot;https://graph.microsoft.com/v1.0/groups/$env:GROUP_ID/members/`$ref&quot;
        $params = @{
            Method      = 'Post'
            Headers     = $authHeader
            Uri         = $graphUri
            ContentType = 'Application/Json'
            body        = @{&quot;@odata.id&quot; = &quot;https://graph.microsoft.com/v1.0/directoryObjects/$($AADDevice.value[0].id)&quot; } | ConvertTo-Json
        }
        Invoke-RestMethod @params
        #endregion
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Conversely, if the device is NOT compliant and exists in the group, letâ€™s handle that as well.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-PowerShell&quot;&gt;if ($firstDevice.complianceState -ne &quot;Compliant&quot;) {
    if ($groupMembers.value -contains $AADDevice.value[0].deviceId) {
        #region device not compliant and exists in group
        $graphUri = &quot;https://graph.microsoft.com/v1.0/groups/$env:GROUP_ID/members/$($AADDevice.value[0].id)/`$ref&quot;
        $params = @{
            Method      = 'DELETE'
            Headers     = $authHeader
            Uri         = $graphUri
            ContentType = 'Application/Json'
        }
        Invoke-RestMethod @params
        #endregion
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So now we have the basic logic for our function app, with a bit of refactoring (to remove duplicate code) some code to help us build a result output, we should end up with a solution that will add all of my compliant devices to a security group!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-PowerShell&quot;&gt;using namespace System.Net

# Input bindings are passed in via param block.
param($Request, $TriggerMetadata)
$result = [System.Collections.ArrayList]::new()
$expectedComplianceValue = &quot;compliant&quot;
#region functions
function Get-AuthHeader {
    param (
        [Parameter(mandatory = $true)]
        [string]$TenantId,
        [Parameter(mandatory = $true)]
        [string]$ClientId,
        [Parameter(mandatory = $true)]
        [string]$ClientSecret,
        [Parameter(mandatory = $true)]
        [string]$ResourceUrl
    )
    $body = @{
        resource      = $ResourceUrl
        client_id     = $ClientId
        client_secret = $ClientSecret
        grant_type    = &quot;client_credentials&quot;
        scope         = &quot;openid&quot;
    }
    try {
        $response = Invoke-RestMethod -Method post -Uri &quot;https://login.microsoftonline.com/$TenantId/oauth2/token&quot; -Body $body -ErrorAction Stop
        $headers = @{ &quot;Authorization&quot; = &quot;Bearer $($response.access_token)&quot; }
        return $headers
    }
    catch {
        Write-Error $_.Exception
    }
}
function Invoke-GraphCall {
    [cmdletbinding()]
    param (
        [parameter(Mandatory = $false)]
        [ValidateSet('Get', 'Post', 'Delete')]
        [string]$Method = 'Get',

        [parameter(Mandatory = $false)]
        [hashtable]$Headers = $script:authHeader,

        [parameter(Mandatory = $true)]
        [string]$Uri,

        [parameter(Mandatory = $false)]
        [string]$ContentType = 'Application/Json',

        [parameter(Mandatory = $false)]
        [hashtable]$Body
    )
    try {
        $params = @{
            Method      = $Method
            Headers     = $Headers
            Uri         = $Uri
            ContentType = $ContentType
        }
        if ($Body) {
            $params.Body = $Body | ConvertTo-Json -Depth 20
        }
        $query = Invoke-RestMethod @params
        return $query
    }
    catch {
        Write-Warning $_.Exception.Message
    }
}
function Format-Result {
    [cmdletbinding()]
    param (
        [parameter(Mandatory = $true)]
        [string]$DeviceID,

        [parameter(Mandatory = $true)]
        [bool]$IsCompliant,

        [parameter(Mandatory = $true)]
        [bool]$IsMember,

        [parameter(Mandatory = $true)]
        [ValidateSet('Added', 'Removed', 'NoActionTaken')]
        [string]$Action
    )
    $result = [PSCustomObject]@{
        DeviceID    = $DeviceID
        IsCompliant = $IsCompliant
        IsMember    = $IsMember
        Action      = $Action
    }
    return $result
}
#endregion
#region authentication
$params = @{
    TenantId     = $env:TENANT_ID
    ClientId     = $env:CLIENT_ID
    ClientSecret = $env:CLIENT_SECRET
    ResourceUrl  = &quot;https://graph.microsoft.com&quot;
}
$script:authHeader = Get-AuthHeader @params
#endregion
#region get devices &amp;amp; group members
$graphUri = 'https://graph.microsoft.com/Beta/deviceManagement/managedDevices'
$query = Invoke-GraphCall -Uri $graphUri

$graphUri = &quot;https://graph.microsoft.com/beta/groups/$env:GROUP_ID/members&quot;
$groupMembers = Invoke-GraphCall -Uri $graphUri
#endregion
#region check each device.
foreach ($device in $query.value) {
    #region get aad object from intune object
    $graphUri = &quot;https://graph.microsoft.com/beta/devices?`$filter=deviceId eq '$($device.azureADDeviceId)'&quot;
    $AADDevice = (Invoke-GraphCall -Uri $graphUri).value
    #endregion
    if ($device.complianceState -eq $expectedComplianceValue) {
        if ($groupMembers.value.deviceId -notcontains $AADDevice.deviceId) {
            #region Device is compliant and not in the group
            $graphUri = &quot;https://graph.microsoft.com/v1.0/groups/$env:GROUP_ID/members/`$ref&quot;
            $body = @{&quot;@odata.id&quot; = &quot;https://graph.microsoft.com/v1.0/directoryObjects/$($AADDevice.id)&quot; }
            Invoke-GraphCall -Uri $graphUri -Method Post -Body $body
            $result.Add($(Format-Result -DeviceID $device.id -IsCompliant $true -IsMember $true -Action Added)) | Out-Null
            #endregion
        }
        else {
            #region device is compliant and already a member
            $result.Add($(Format-Result -DeviceID $device.id -IsCompliant $true -IsMember $true -Action NoActionTaken)) | Out-Null
            #endregion
        }
    }
    else {
        if ($groupMembers.value.deviceId -contains $AADDevice.deviceId) {
            #region device not compliant and exists in group
            $graphUri = &quot;https://graph.microsoft.com/v1.0/groups/$env:GROUP_ID/members/$($AADDevice.id)/`$ref&quot;
            Invoke-GraphCall -Uri $graphUri -Method Delete
            $result.Add($(Format-Result -DeviceID $device.id -IsCompliant $false -IsMember $false -Action Removed)) | Out-Null
            #endregion
        }
        else {
            #region device not compliant and is not a member
            $result.Add($(Format-Result -DeviceID $device.id -IsCompliant $false -IsMember $false -Action NoActionTaken))
            #endregion
        }
    }
}
#endregion
# Associate values to output bindings by calling 'Push-OutputBinding'.
Push-OutputBinding -Name Response -Value ([HttpResponseContext]@{
        StatusCode = [HttpStatusCode]::OK
        Body       = $result | ConvertTo-Json -Depth 20
    })
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we now spin up a local instance of our function app (or run it from Azure for those testing in productionðŸ¤ ) we can trigger the function app from the URI and see the resultsâ€¦&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/2021/06/pwsh_005.gif&quot; title=&quot;It lives!&quot;&gt;&lt;img src=&quot;/assets/images/2021/06/pwsh_005.gif&quot; alt=&quot;It lives!&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Awesome! Now, there is more that needs to be done before this could be safely used in production - specifically putting in some logic to handle large amounts of devices via batched Graph calls and Iâ€™d be switching out the HTTP Trigger binding for a CRON job to automate the task, but I hope this will give you ideas for ways to build your dynamic group automation.&lt;/p&gt;

&lt;p&gt;Donâ€™t let the above example think you are limited to just properties via Graph either, keeping the HTTP trigger on the function app, I could imagine scenarios where proactive remediation scripts run on client devices to check for the presence of an application and force the function app to trigger..&lt;/p&gt;

&lt;p&gt;As always, &lt;a href=&quot;https://github.com/tabs-not-spaces/CodeDump/tree/master/Dynamic-Group-Automation&quot;&gt;the full code from this article is available on Github&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;â€” Ben&lt;/p&gt;</content><author><name>Ben</name></author><category term="PowerShell" /><category term="Azure" /><category term="Intune" /><category term="Azure Functions" /><category term="PowerShell" /><category term="Azure" /><category term="Intune" /><category term="Azure Functions" /><summary type="html">Iâ€™ve never been entirely happy with dynamic groups in Intune. The primary reason for this boils down to two primary issues: The time it takes to analyze the dynamic group rules is nowhere near fast enough. The available properties available for dynamic group rules are limited to the data available in AAD - not Intune.</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://powers-hell.com/assets/images/2021/06/pwsh_005.gif" /><media:content medium="image" url="https://powers-hell.com/assets/images/2021/06/pwsh_005.gif" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Working with Intune Settings Catalog using PowerShell and Graph</title><link href="https://powers-hell.com/2021/03/08/working-with-intune-settings-catalog-using-powershell-and-graph/" rel="alternate" type="text/html" title="Working with Intune Settings Catalog using PowerShell and Graph" /><published>2021-03-08T12:46:00+00:00</published><updated>2021-03-08T12:46:00+00:00</updated><id>https://powers-hell.com/2021/03/08/working-with-intune-settings-catalog-using-powershell-and-graph</id><content type="html" xml:base="https://powers-hell.com/2021/03/08/working-with-intune-settings-catalog-using-powershell-and-graph/">&lt;p&gt;Microsoft has recently introduced even more ways to create device configuration profiles..&lt;/p&gt;

&lt;p&gt;The new profile type, named &lt;strong&gt;Settings Catalog&lt;/strong&gt;, allows us to explicitly define and configure a policy that has &lt;strong&gt;only&lt;/strong&gt; the settings that they want for that profile, nothing more. Additionally, the existing configuration profiles and ADMX templates have been migrated to the &lt;strong&gt;templates&lt;/strong&gt; profile type.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;a href=&quot;https://user-images.githubusercontent.com/33951277/119915226-66caae00-bfa5-11eb-8cc5-4eccfce7787e.png&quot; title=&quot;Create a setting profile&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/33951277/119915226-66caae00-bfa5-11eb-8cc5-4eccfce7787e.png&quot; alt=&quot;&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;I sat down with &lt;a href=&quot;https://twitter.com/MikeDanoski&quot;&gt;Mike Danoski&lt;/a&gt; for an in-depth chat about this on the &lt;a href=&quot;https://intune.training&quot; data-type=&quot;URL&quot; data-id=&quot;https://intune.training&quot;&gt;Intune.Training&lt;/a&gt; Channel (video below).&lt;/p&gt;

&lt;div class=&quot;video-container&quot;&gt;
    &lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/sqIKcWXPvyI&quot; title=&quot;YouTube video player&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;p&gt;After spending time with Mike and seeing how settings catalog profiles work from the endpoint portal user interface, I immediately wanted to see what I could do with this new device management framework via graph.&lt;/p&gt;

&lt;p&gt;So letâ€™s dive in and play!&lt;/p&gt;

&lt;h2 id=&quot;pulling-settings-catalog-policies-from-graph&quot;&gt;&lt;strong&gt;Pulling settings catalog policies from Graph&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;First, letâ€™s create a policy from the endpoint portal and see what is required to retrieve the policy data.&lt;/p&gt;

&lt;p&gt;For this demo, Iâ€™ve created a simple settings catalog with a few settings around bitlocker as shown below.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://user-images.githubusercontent.com/33951277/119915357-ad200d00-bfa5-11eb-97fc-2cef877def1a.png&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/33951277/119915357-ad200d00-bfa5-11eb-97fc-2cef877def1a.png&quot; alt=&quot;image-1&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The first thing we need to do, as always, is authenticate to graph - At this point I shouldnâ€™t need to explain what is happening here. We will use the msal.ps module to make things easier.&lt;/p&gt;

&lt;pre class=&quot;wp-block-code&quot; title=&quot;Configure Authentication for Graph.&quot;&gt;&lt;code lang=&quot;powershell&quot; class=&quot;language-powershell&quot;&gt;$params = @{
    ClientId = 'd1ddf0e4-d672-4dae-b554-9d5bdfd93547'
    TenantId = 'powers-hell.com'
    DeviceCode = $true
}
$AuthHeader = @{Authorization = (Get-MsalToken @params).CreateAuthorizationHeader()}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now that weâ€™ve authenticated to graph, letâ€™s use the new graph endpoint &lt;strong&gt;configurationPolicies&lt;/strong&gt; to have a look at how this new feature looks in the backend.&lt;/p&gt;

&lt;pre class=&quot;wp-block-code&quot; title=&quot;Get configurationPolicies&quot;&gt;&lt;code lang=&quot;powershell&quot; class=&quot;language-powershell&quot;&gt;$baseUri = &quot;https://graph.microsoft.com/beta/deviceManagement&quot;
$restParam = @{
    Method = 'Get'
    Uri = &quot;$baseUri/configurationPolicies&quot;
    Headers = $authHeaders
    ContentType = 'Application/json'
}

$configPolicies = Invoke-RestMethod @restParam
$configPolicies.value&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see, the code above is quite simple, and looking at the resultant data shows we get some basic data back showing all available &lt;strong&gt;settings catalog&lt;/strong&gt; policies that are in our tenant (in our case just the one).&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://user-images.githubusercontent.com/33951277/119915408-ca54db80-bfa5-11eb-9be7-d9d02f8cd82c.png&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/33951277/119915408-ca54db80-bfa5-11eb-9be7-d9d02f8cd82c.png&quot; alt=&quot;image-2&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Ok, so weâ€™ve got the basic metadata of our policy - so letâ€™s grab the id from the previous call and dive in further..&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-PowerShell&quot;&gt;$policyId = $configPolicies.value[0].id #grabbing the id from the previous code block
$restParam = @{
    Method = 'Get'
    Uri = &quot;$baseUri/configurationPolicies('$policyId')/settings&quot;
    Headers = $authHeaders
    ContentType = 'Application/json'
}

$configPolicySettings = Invoke-RestMethod @restParam
$configPolicySettings.value
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The code above returns data on all available settings that we configured in our policy..&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://user-images.githubusercontent.com/33951277/119915446-e5bfe680-bfa5-11eb-95ee-c997cae4af14.png&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/33951277/119915446-e5bfe680-bfa5-11eb-95ee-c997cae4af14.png&quot; alt=&quot;image-3&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;if we drill in to one of the &lt;strong&gt;settingInstance&lt;/strong&gt; objects, we should see more info..&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://user-images.githubusercontent.com/33951277/119915455-ea849a80-bfa5-11eb-8e0a-e3b960be372e.png&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/33951277/119915455-ea849a80-bfa5-11eb-8e0a-e3b960be372e.png&quot; alt=&quot;image-4&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;As we can see, this particular setting is for &lt;strong&gt;allow warning for other disk encryption&lt;/strong&gt; - as clearly defined in the &lt;strong&gt;definitionId&lt;/strong&gt; value. If we drill into the &lt;strong&gt;choiceSettingValue&lt;/strong&gt; item, we will see the applied value and any other child properties within that setting..&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://user-images.githubusercontent.com/33951277/119915465-efe1e500-bfa5-11eb-868b-3201648c081f.png&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/33951277/119915465-efe1e500-bfa5-11eb-868b-3201648c081f.png&quot; alt=&quot;image-5&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Here we can see the value of &lt;strong&gt;allow warning for other disk encryption&lt;/strong&gt; is set to 0 - or false, which correlates to our policy set from the endpoint portal.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://user-images.githubusercontent.com/33951277/119915536-1011a400-bfa6-11eb-8421-eeca2c61bcb9.png&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/33951277/119915536-1011a400-bfa6-11eb-8421-eeca2c61bcb9.png&quot; alt=&quot;image-6&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Here we can see the &lt;strong&gt;child&lt;/strong&gt; setting of &lt;strong&gt;allow standard user encryption&lt;/strong&gt; with the setting value of 1 - or true.&lt;/p&gt;

&lt;p&gt;This example shows how simple it is to capture the basic building blocks of a settings catalog policy. But for those interested to dig deeper, why not check out what happens when you run the same example from above while expanding the &lt;strong&gt;settingDefinitions&lt;/strong&gt; property..&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://user-images.githubusercontent.com/33951277/119915557-1acc3900-bfa6-11eb-8374-b50a0a1b2d82.gif&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/33951277/119915557-1acc3900-bfa6-11eb-8374-b50a0a1b2d82.gif&quot; alt=&quot;settingsDefinition&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Cool, huh? literally everything about each and every setting is available to us if we just spend the time to dig into graph a little bit!&lt;/p&gt;

&lt;h2 id=&quot;building-a-policy-from-scratch&quot;&gt;Building a policy from scratch&lt;/h2&gt;

&lt;p&gt;Now, before we begin, Iâ€™m going to put this out there - settings catalog policies are probably not the easiest things to build from scratch..&lt;/p&gt;

&lt;p&gt;There is LOTS of metadata that you need to know for each setting before you can build out the policies. However, the concepts shown below can also be leveraged to maintain &lt;strong&gt;reference templates&lt;/strong&gt; that can be captured and redeployed to other tenants to allow seamless management of multiple tenants with minimal effort.&lt;/p&gt;

&lt;p&gt;Enough stalling, letâ€™s see whatâ€™s required.&lt;/p&gt;

&lt;h3 id=&quot;getting-all-settings-data&quot;&gt;Getting all settings data&lt;/h3&gt;

&lt;p&gt;So the first question that you may be asking, is, â€œHow do I get the data that I need for the settings that I want to add to my catalog policy?â€ Luckily, Microsoft has an endpoint in graph that will return all possible settings currently available for the settings catalog.&lt;/p&gt;

&lt;p&gt;We can capture all necessary metadata on those available settings by using the &lt;strong&gt;deviceManagement/configurationSettings&lt;/strong&gt; endpoint.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-PowerShell&quot;&gt;$restParam = @{
    Method = &quot;Get&quot;
    Uri = &quot;$baseUri/configurationSettings&quot;
    Headers = $authHeaders
    ContentType = 'Application/Json'
}
$settingsData = Invoke-RestMethod @restParam
$settingsData.value
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Letâ€™s run the above code and see what we get back..&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://user-images.githubusercontent.com/33951277/119915626-40f1d900-bfa6-11eb-9bd0-cab0d19c0e2f.gif&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/33951277/119915626-40f1d900-bfa6-11eb-9bd0-cab0d19c0e2f.gif&quot; alt=&quot;settingsCatapalooza&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Wellâ€¦ that was a bit much wasnâ€™t it! at the time of writing, there is around 2,100 settings available in the settings catalog library with more to come until it is at parity with all existing methods of device configuration (configuration items, ADMX templates, endpoint baselines etc).&lt;/p&gt;

&lt;p&gt;Letâ€™s filter the settings by a setting &lt;strong&gt;definitionId&lt;/strong&gt; that we know (notice that the definitionId isnt a GUID? welcome to the futureâ€¦)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-PowerShell&quot;&gt;$settingsData.value | where {$_.id -eq 'device_vendor_msft_bitlocker_allowwarningforotherdiskencryption'}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&quot;https://user-images.githubusercontent.com/33951277/119915662-52d37c00-bfa6-11eb-8d82-623eafe6e2b1.png&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/33951277/119915662-52d37c00-bfa6-11eb-8d82-623eafe6e2b1.png&quot; alt=&quot;image-7&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Weirdâ€¦ doesnâ€™t that look the same as the expanded &lt;strong&gt;settingsDefinitions&lt;/strong&gt; content from earlier? Thatâ€™s because it is literally the same data! We can dig into this data to find out the available options for each setting, but letâ€™s skip that for now and just build our example policy from scratch..&lt;/p&gt;

&lt;h3 id=&quot;posting-a-settings-catalog-policy-to-intune-from-graph&quot;&gt;Posting a settings catalog policy to Intune from Graph&lt;/h3&gt;

&lt;p&gt;Conceptually we now should understand whatâ€™s required here. We have some metadata around what the policy is called to which we attach whichever settings we want attributed to our new policy profile. So letâ€™s rebuild the original policy in PowerShell!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-PowerShell&quot;&gt;$baseUri = 'https://graph.microsoft.com/beta/deviceManagement/configurationPolicies'

#region build the policy
$newPolicy = [pscustomobject]@{
    name         = &quot;Bitlocker Policy from PowerShell&quot;
    description  = &quot;we built this from PowerShell!&quot;
    platforms    = &quot;windows10&quot;
    technologies = &quot;mdm&quot;
    settings     = @(
        @{
            '@odata.type'   = &quot;#microsoft.graph.deviceManagementConfigurationSetting&quot;
            settingInstance = @{
                '@odata.type'       = &quot;#microsoft.graph.deviceManagementConfigurationChoiceSettingInstance&quot;
                settingDefinitionId = &quot;device_vendor_msft_bitlocker_allowwarningforotherdiskencryption&quot;
                choiceSettingValue  = @{
                    '@odata.type' = &quot;#microsoft.graph.deviceManagementConfigurationChoiceSettingValue&quot;
                    value         = &quot;device_vendor_msft_bitlocker_allowwarningforotherdiskencryption_0&quot;
                    children      = @(
                        @{
                            '@odata.type'       = &quot;#microsoft.graph.deviceManagementConfigurationChoiceSettingInstance&quot;
                            settingDefinitionId = &quot;device_vendor_msft_bitlocker_allowstandarduserencryption&quot;
                            choiceSettingValue  = @{
                                '@odata.type' = &quot;#microsoft.graph.deviceManagementConfigurationChoiceSettingValue&quot;
                                value         = &quot;device_vendor_msft_bitlocker_allowstandarduserencryption_0&quot;
                            }
                        }
                    )
                }
            }
        }
        @{
            '@odata.type'   = &quot;#microsoft.graph.deviceManagementConfigurationSetting&quot;
            settingInstance = @{
                '@odata.type'       = &quot;#microsoft.graph.deviceManagementConfigurationChoiceSettingInstance&quot;
                settingDefinitionId = &quot;device_vendor_msft_bitlocker_requiredeviceencryption&quot;
                choiceSettingValue  = @{
                    '@odata.type' = &quot;#microsoft.graph.deviceManagementConfigurationChoiceSettingValue&quot;
                    value         = &quot;device_vendor_msft_bitlocker_requiredeviceencryption_1&quot;
                }
            }
        }
    )
}
#endregion
#region post the request
$restParams = @{
    Method      = 'Post'
    Uri         = $baseUri
    body        = ($newPolicy | ConvertTo-Json -Depth 20)
    Headers     = $authHeaders
    ContentType = 'Application/Json'
}
Invoke-RestMethod @restParams
#endregion
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once we run this - within seconds we should have a replicated policy in our tenant!&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://user-images.githubusercontent.com/33951277/119915697-65e64c00-bfa6-11eb-8cab-06a15f01b7e8.png&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/33951277/119915697-65e64c00-bfa6-11eb-8cab-06a15f01b7e8.png&quot; alt=&quot;image-8&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;As mentioned earlier, building these from scratch is tricky - but if you read between the lines, knowing how to capture pre-built policies via graph and using the captured JSON payload to post the same policy to a new tenant (or a few hundred tenants) should make multi-tenant device management less painful.&lt;/p&gt;

&lt;p&gt;â€” Ben&lt;/p&gt;</content><author><name>Ben</name></author><category term="Azure" /><category term="Graph" /><category term="Intune" /><category term="PowerShell" /><category term="Azure" /><category term="Intune" /><category term="PowerShell" /><summary type="html">Microsoft has recently introduced even more ways to create device configuration profiles.. The new profile type, named Settings Catalog, allows us to explicitly define and configure a policy that has only the settings that they want for that profile, nothing more. Additionally, the existing configuration profiles and ADMX templates have been migrated to the templates profile type.</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://powers-hell.com/assets/images/2021/03/settingsCatapalooza.gif" /><media:content medium="image" url="https://powers-hell.com/assets/images/2021/03/settingsCatapalooza.gif" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Publishing PowerShell scripts to Intune with Graph</title><link href="https://powers-hell.com/2021/01/19/publishing-powershell-scripts-to-intune-with-graph/" rel="alternate" type="text/html" title="Publishing PowerShell scripts to Intune with Graph" /><published>2021-01-19T03:22:12+00:00</published><updated>2021-01-19T03:22:12+00:00</updated><id>https://powers-hell.com/2021/01/19/publishing-powershell-scripts-to-intune-with-graph</id><content type="html" xml:base="https://powers-hell.com/2021/01/19/publishing-powershell-scripts-to-intune-with-graph/">&lt;p&gt;Iâ€™ve recently been asked the question - â€œHow can I make sure that the scripts that I publish to Intune are always set to run as 64bit instead of the default 32bit?â€&lt;/p&gt;

&lt;p&gt;I thought was a great question with a few simple solutions - so letâ€™s look at the two methods Iâ€™ve used in the past to make sure you donâ€™t â€œfat fingerâ€ your way into frustration!&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;enforce-architecture-from-the-script&quot;&gt;Enforce architecture from the script&lt;/h2&gt;

&lt;p&gt;When PowerShell script deployment was initially released within Intune there was no native way to define what architecture the script would run in. This means that the script would always run in the 32bit / x86 environment as the Intune Management Extension agent was launching the scripts and the agent itself was a 32bit agent - it had no way to bootstrap out of the 32bit environment!&lt;/p&gt;

&lt;p&gt;The only solution during this period was to make your scripts bootstrap themselves into 64bit with a little bit of PowerShell magic.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-PowerShell&quot;&gt;#region 64-bit elevation
if ($env:PROCESSOR_ARCHITEW6432 -eq &quot;AMD64&quot;) {
    write-Host &quot;pull on those bootstraps...&quot;
    if ($myInvocation.Line) {
        &amp;amp;&quot;$env:WINDIR\sysnative\windowspowershell\v1.0\powershell.exe&quot; -NonInteractive -executionPolicy Bypass -NoProfile $myInvocation.Line
    }
    else {
        &amp;amp;&quot;$env:WINDIR\sysnative\windowspowershell\v1.0\powershell.exe&quot; -NonInteractive -executionPolicy Bypass -NoProfile -file &quot;$($myInvocation.InvocationName)&quot; $args
    }
    exit $lastexitcode
}
#endregion
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Place that code at the top of any script you publish to Intune and you can rest easy knowing that your code will always run in the environment it should be in, regardless if you set it correctly from within Intune or not.&lt;/p&gt;

&lt;h2 id=&quot;avoid-the-endpoint-ui-and-use-graph&quot;&gt;Avoid the Endpoint UI and use Graph&lt;/h2&gt;

&lt;p&gt;Now that the option to set the architecture from within the script deployment, the above solution is conceivably â€œredundantâ€ - we can set everything when we publish the script in the portal now!&lt;/p&gt;

&lt;p&gt;The problem arises however, because the default architecture setting is set to 32bit instead of the generally expected 64bit, that you can sometimes forget to set the configuration correctly from the portal.&lt;/p&gt;

&lt;p&gt;Luckily, we can move away from the Endpoint portal and use PowerShell and Graph to change the default settings to values and standardize our script publishing to avoid any of those absent-minded â€œuser errorsâ€ that are so frustratingly common.&lt;/p&gt;

&lt;p&gt;Like all other configuration settings / device management endpoints that are exposed via Graph, all that is required is to:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Understand how the JSON payload data is formed&lt;/li&gt;
  &lt;li&gt;Authenticate to Graph&lt;/li&gt;
  &lt;li&gt;Build and publish the JSON payload to Graph&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The one extra step for script deployment is that we need to encode the script content into a base64 encoded string so that we can post the file within the JSON payload.&lt;/p&gt;

&lt;p&gt;Letâ€™s dive into the solution together.&lt;/p&gt;

&lt;h3 id=&quot;authentication&quot;&gt;Authentication&lt;/h3&gt;

&lt;p&gt;Iâ€™ve covered this ad-nauseum, so I wonâ€™t spend time explaining it - but hereâ€™s the code snippet we will use for this example. Whatâ€™s cool about this is we can handle whether or not the end user uses PowerShell 5.1 or 7.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-PowerShell&quot;&gt;#region authenticate to Graph
if ($PSVersionTable.PSEdition -ne &quot;Core&quot;) {
    $auth = Get-MsalToken -ClientId &quot;d1ddf0e4-d672-4dae-b554-9d5bdfd93547&quot; -RedirectUri &quot;urn:ietf:wg:oauth:2.0:oob&quot; -Interactive
}
else {
    $auth = Get-MsalToken -ClientId &quot;d1ddf0e4-d672-4dae-b554-9d5bdfd93547&quot; -DeviceCode
}
$script:authToken = @{
    Authorization = $auth.CreateAuthorizationHeader()
}
#endregion
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;encode-the-script-to-a-base64-string&quot;&gt;Encode the script to a base64 string&lt;/h3&gt;

&lt;p&gt;Very simple - but super important. We just need to get the raw content of the script and throw it into the .Net â€œSystem.Convertâ€ type.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-PowerShell&quot;&gt;#region encode the script content to base64
$scriptContent = Get-Content &quot;C:\Path\To\Script.ps1&quot; -Raw
$encodedScriptContent = [System.Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes(&quot;$scriptContent&quot;))
#endregion
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;payload-properties&quot;&gt;Payload properties&lt;/h3&gt;

&lt;p&gt;The required properties for publishing scripts to Graph are quite simple - the endpoint &lt;strong&gt;deviceManagementScripts&lt;/strong&gt; is &lt;a href=&quot;https://docs.microsoft.com/en-us/graph/api/intune-shared-devicemanagementscript-create?view=graph-rest-beta&quot; data-type=&quot;URL&quot; data-id=&quot;https://docs.microsoft.com/en-us/graph/api/intune-shared-devicemanagementscript-create?view=graph-rest-beta&quot;&gt;well documented&lt;/a&gt;, but for simplicity, the only settings we need to understand are listed below:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;&lt;strong&gt;Property Name&lt;/strong&gt;&lt;/th&gt;
      &lt;th&gt;&lt;strong&gt;Data Type&lt;/strong&gt;&lt;/th&gt;
      &lt;th&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;displayName&lt;/td&gt;
      &lt;td&gt;String&lt;/td&gt;
      &lt;td&gt;Name of the device management script.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;description&lt;/td&gt;
      &lt;td&gt;String&lt;/td&gt;
      &lt;td&gt;Description of the script&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;enforceSignatureCheck&lt;/td&gt;
      &lt;td&gt;Boolean&lt;/td&gt;
      &lt;td&gt;Setting this to False disables signature check.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;fileName&lt;/td&gt;
      &lt;td&gt;String&lt;/td&gt;
      &lt;td&gt;Name of the file being uploaded.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;runas32Bit&lt;/td&gt;
      &lt;td&gt;Boolean&lt;/td&gt;
      &lt;td&gt;Setting this to False sets to 64bit&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;runAsAccount&lt;/td&gt;
      &lt;td&gt;String&lt;/td&gt;
      &lt;td&gt;Execution context - System or User&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;scriptContent&lt;/td&gt;
      &lt;td&gt;Binary&lt;/td&gt;
      &lt;td&gt;Script content - encoded as base64&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;So, knowing what we need, letâ€™s build out the code to build the payload.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-PowerShell&quot;&gt;#region build the request body
$postBody = [PSCustomObject]@{
    displayName           = &quot;Powers-Hell Configuration Script&quot;
    description           = &quot;script that configures important things&quot;
    enforceSignatureCheck = $false
    fileName              = &quot;Script.ps1&quot;
    runAs32Bit            = $false
    runAsAccount          = &quot;System&quot;
    scriptContent         = $encodedScriptContent
} | ConvertTo-Json -Depth 10
#endregion
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Quite simple - creating a PSCustomObject, filling in the property values and then immediately converting to a JSON string.&lt;/p&gt;

&lt;h3 id=&quot;post-the-request-to-graph&quot;&gt;Post the request to Graph&lt;/h3&gt;

&lt;p&gt;Once weâ€™ve got out authentication header, weâ€™ve encoded the script contents and built out the JSON payload, all thatâ€™s left to do is post the payload to the Graph endpoint.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-PowerShell&quot;&gt;#region post the request
$postParams = @{
    Method      = &quot;Post&quot;
    Uri         = &quot;https://graph.microsoft.com/Beta/deviceManagement/deviceManagementScripts&quot;
    Headers     = $script:authToken
    Body        = $postBody
    ContentType = &quot;Application/Json&quot;
}
Invoke-RestMethod @postParams
#endregion
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we use the above basic blocks of code, we can very easily build a simple function to allow us to build out a request to publish scripts to our Intune tenant and by forcing the boolean value of &lt;strong&gt;runAs32Bit&lt;/strong&gt; to $false, we can ensure the script will always run correctly - even if we havenâ€™t had enough coffee yet.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-PowerShell&quot;&gt;#requires -module msal.ps
function Publish-ScriptToIntune {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory = $true)]
        [System.IO.FileInfo]$ScriptFilePath,

        [Parameter(Mandatory = $true)]
        [string]$DisplayName,

        [Parameter(Mandatory = $true)]
        [string]$Description,

        [Parameter(Mandatory = $false)]
        [ValidateSet(&quot;System&quot;, &quot;User&quot;)]
        [string]$RunAsAccount = &quot;System&quot;,

        [Parameter(Mandatory = $false)]
        [boolean]$EnforceSignatureCheck,

        [Parameter(Mandatory = $false)]
        [boolean]$RunAs32Bit

    )
    try {
        $script:tick = [char]0x221a
        $errorMsg = $null
        #region authenticate to Graph
        if ($PSVersionTable.PSEdition -ne &quot;Core&quot;) {
            $auth = Get-MsalToken -ClientId &quot;d1ddf0e4-d672-4dae-b554-9d5bdfd93547&quot; -RedirectUri &quot;urn:ietf:wg:oauth:2.0:oob&quot; -Interactive
        }
        else {
            $auth = Get-MsalToken -ClientId &quot;d1ddf0e4-d672-4dae-b554-9d5bdfd93547&quot; -DeviceCode
        }
        if (!($auth)) {
            throw &quot;Authentication failed.&quot;
        }
        $script:authToken = @{
            Authorization = $auth.CreateAuthorizationHeader()
        }
        #endregion
        #region encode the script content to base64
        $scriptContent = Get-Content &quot;$ScriptFilePath&quot; -Raw
        $encodedScriptContent = [System.Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes(&quot;$scriptContent&quot;))
        #endregion
        #region build the request body
        $postBody = [PSCustomObject]@{
            displayName           = $DisplayName
            description           = $Description
            enforceSignatureCheck = $EnforceSignatureCheck
            fileName              = $ScriptFilePath.Name
            runAs32Bit            = $RunAs32Bit
            runAsAccount          = $RunAsAccount
            scriptContent         = $encodedScriptContent
        } | ConvertTo-Json -Depth 10
        #endregion
        Write-Host &quot;`nPosting script content to Intune: &quot; -NoNewline -ForegroundColor Cyan
        #region post the request
        $postParams = @{
            Method      = &quot;Post&quot;
            Uri         = &quot;https://graph.microsoft.com/Beta/deviceManagement/deviceManagementScripts&quot;
            Headers     = $script:authToken
            Body        = $postBody
            ContentType = &quot;Application/Json&quot;
        }
        if ($PSCmdlet.MyInvocation.BoundParameters[&quot;Verbose&quot;].IsPresent) {
            Write-Host &quot;`n&quot;
        }
        $res = Invoke-RestMethod @postParams
        #endregion
    }
    catch {
        $errorMsg = $_.Exception.Message
    }
    finally {
        if ($auth) {
            if ($errorMsg) {
                Write-Host &quot;X`n&quot; -ForegroundColor Red
                Write-Warning $errorMsg
            }
            else {
                if ($PSCmdlet.MyInvocation.BoundParameters[&quot;Verbose&quot;].IsPresent) {
                    $res
                }
                Write-Host &quot;$script:tick Script published to Intune with ID $($res.id)&quot; -ForegroundColor Green
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As always, the code featured is available in my &lt;a href=&quot;https://github.com/tabs-not-spaces/CodeDump/tree/master/Publish-ScriptToIntune&quot;&gt;GitHub&lt;/a&gt; and Iâ€™m always up for a chat on &lt;a href=&quot;https://twitter.com/powers_hell&quot;&gt;Twitter&lt;/a&gt;!&lt;/p&gt;

&lt;p&gt;â€” Ben&lt;/p&gt;</content><author><name>Ben</name></author><category term="Azure" /><category term="Graph" /><category term="Intune" /><category term="PowerShell" /><category term="Graph" /><category term="Intune" /><category term="PowerShell" /><summary type="html">I've recently been asked the question - &quot;How can I make sure that the scripts that I publish to Intune are always set to run as 64bit instead of the default 32bit?&quot; I thought was a great question with a few simple solutions - so let's look at the two methods I've used in the past to make sure you don't &quot;fat finger&quot; your way into frustration!</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://powers-hell.com/assets/images/2021/01/scriptToGraph.gif" /><media:content medium="image" url="https://powers-hell.com/assets/images/2021/01/scriptToGraph.gif" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Set your Azure VPN connections to â€œConnect Automaticallyâ€ with PowerShell</title><link href="https://powers-hell.com/2020/11/28/set-your-azure-vpn-connections-to-connect-automatically-with-powershell/" rel="alternate" type="text/html" title="Set your Azure VPN connections to â€œConnect Automaticallyâ€ with PowerShell" /><published>2020-11-28T06:25:27+00:00</published><updated>2020-11-28T06:25:27+00:00</updated><id>https://powers-hell.com/2020/11/28/set-your-azure-vpn-connections-to-connect-automatically-with-powershell</id><content type="html" xml:base="https://powers-hell.com/2020/11/28/set-your-azure-vpn-connections-to-connect-automatically-with-powershell/">&lt;p&gt;One of my clients recently came to me asking for assistance to set up a new VPN solution. The requirements were quite simple - They were building out an Azure Point-To-Site VPN solution and needed me to come up with a way to deliver the connection to the end user devices.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;My first suggestion was to simply use the built-in VPN client that comes with Windows 10. If we use this, we can utilize the native VPN policies within Intune which let us define everything we need - including setting the connection to automatically connect. The problem, as it turned out is the native VPN client has a limit of 25 route rules per connection - something that *shouldnâ€™t* normally be a problem, but was insurmountable in this scenario.&lt;/p&gt;

&lt;p&gt;The next suggestion was to leverage the &lt;a href=&quot;https://www.microsoft.com/en-us/p/azure-vpn-client/9np355qt2sqb&quot; data-type=&quot;URL&quot; data-id=&quot;https://www.microsoft.com/en-us/p/azure-vpn-client/9np355qt2sqb&quot;&gt;Azure VPN Client&lt;/a&gt; from the Microsoft store. This VPN client is designed to compliment the native VPN client and adds support for MFA as well as allowing connections from the native VPN interface.&lt;/p&gt;

&lt;p&gt;The only problem? There is no way to force the â€œconnect automaticallyâ€ setting in the native VPN client, thus the clientâ€™s major requirement was not met.&lt;/p&gt;

&lt;p&gt;Now, the end user can technically go in once the connection is deployed and set it themselves, but there has to be a more reliable way of doing this on behalf of the user - if it can be done via Intune for the native client, surely there has to be a way to enforce the setting? The answer, as always, is a resounding â€œof course!â€.&lt;/p&gt;

&lt;p&gt;Before we begin, the first thing we need to do is convert the config files I was given by my network team into a format that we can silently push out.&lt;/p&gt;

&lt;p&gt;Once youâ€™ve downloaded the Azure P2S config files, the next step is to manually import the config into the Azure VPN client (technically there is a way to do this using CLI parameters, however itâ€™s frustratingly broken at the moment - Iâ€™ll talk about that another time!).&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/2020/11/VPNConnectionImport-1.gif&quot; title=&quot;VPN Connection Import&quot;&gt;&lt;img src=&quot;/assets/images/2020/11/VPNConnectionImport-1.gif&quot; alt=&quot;VPN Connection Import&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;What this manual step does is creates the *.PBK file that the VPN client uses to â€œdial the connectionâ€. Once we have that *.PBK file generated, we can capture the contents, and then deploy it out to other devices via Intune (or Configuration Manager) using a very simple PowerShell script.&lt;/p&gt;

&lt;p&gt;The *.PBK file is stored within the Azure VPN client folder structure in your local app data folder shown below - Itâ€™s always the same path which makes all of this very easy to automate!&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;%localappdata%\Packages\Microsoft.AzureVpn_8wekyb3d8bbwe\LocalState\rasphone.pbk&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Open the *.pbk file in your favourite editor (thatâ€™s VSCode for everyone right?) and letâ€™s move onto the code.&lt;/p&gt;

&lt;pre class=&quot;wp-block-code&quot; title=&quot;Deploy and configure VPN&quot;&gt;&lt;code lang=&quot;powershell&quot; class=&quot;language-powershell line-numbers&quot;&gt;
#region Configuration
$VPNName = 'Powers Hell VPN Connection'
$VPNGUID = 'F3910F5AC434944F9335C187D7476DB4'
$currentUser = (Get-CimInstance -ClassName WIn32_Process -Filter 'Name=&quot;explorer.exe&quot;' | Invoke-CimMethod -MethodName GetOwner)[0]
$objUser = New-Object System.Security.Principal.NTAccount($currentUser.user)
$strSID = $objUser.Translate([System.Security.Principal.SecurityIdentifier])
$requiredFolder = &quot;C:\Users\$($currentUser.user)\AppData\Local\Packages\Microsoft.AzureVpn_8wekyb3d8bbwe\LocalState&quot;
$rasManKeyPath = &quot;HKLM:\SYSTEM\CurrentControlSet\Services\RasMan\Config&quot;
#endregion
#region PBK Configuration
$PBKConfig - @&quot;
#Place your PBK contents here...
&quot;@
#endregion
#region Functions
function Write-Log {
    [cmdletbinding()]
    param (
        [string]$logMessage
    )
    Write-Host &quot;[$(Get-Date -Format 'dd-MM-yyyy_HH:mm:ss')] $logMessage&quot; -ForegroundColor Yellow
}
#endregion
#region Deploy VPN
if (!(Test-Path $RequiredFolder -ErrorAction SilentlyContinue)) {
  New-Item $RequiredFolder -ItemType Directory | Out-Null
  $LogLocation = &quot;$RequiredFolder\NewAzureVPNConnectionLog_$(Get-Date -Format 'dd-MM-yyyy_HH_mm_ss').log&quot;
  Start-Transcript -Path $LogLocation -Force -Append

  Write-Log &quot;Required folder $RequiredFolder was created on the machine since it wasn't found.&quot;
  New-Item &quot;$RequiredFolder\rasphone.pbk&quot; -ItemType File | Out-Null

  Write-Log &quot;File rasphone.pbk has been created in $RequiredFolder.&quot;
  Set-Content &quot;$RequiredFolder\rasphone.pbk&quot; $PBKConfig

  Write-Log &quot;File rasphone.pbk has been populated with configuration details.&quot;
  Stop-Transcript | Out-Null
}
else {
  $LogLocation = &quot;$RequiredFolder\NewAzureVPNConnectionLog_$(Get-Date -Format 'dd-MM-yyyy_HH_mm_ss').log&quot;
  Start-Transcript -Path $LogLocation -Force -Append

  Write-Log &quot;Folder $RequiredFolder already exists, that means that Azure VPN Client is already installed.&quot;
  if (!(Test-Path &quot;$RequiredFolder\rasphone.pbk&quot; -ErrorAction SilentlyContinue)) {

    Write-Log &quot;File rasphone.pbk doesn't exist in $RequiredFolder.&quot;
    New-Item &quot;$RequiredFolder\rasphone.pbk&quot; -ItemType File | Out-Null

    Write-Log &quot;File rasphone.pbk has been created in $RequiredFolder.&quot;
    Set-Content &quot;$RequiredFolder\rasphone.pbk&quot; $PBKConfig

    Write-Log &quot;File rasphone.pbk has been populated with configuration details.&quot;
    Stop-Transcript | Out-Null
  }
  else {
    Write-Log &quot;File rasphone.pbk already exists in $RequiredFolder.&quot;
    Rename-Item -Path &quot;$RequiredFolder\rasphone.pbk&quot; -NewName &quot;$RequiredFolder\rasphone.pbk_$(Get-Date -Format 'ddMMyyyy-HHmmss')&quot;

    Write-Log &quot;File rasphone.pbk has been renamed to rasphone.pbk_$(Get-Date -Format 'ddMMyyyy-HHmmss'). This file contains old configuration if it will be required in the future (in case it is, just rename it back to rasphone.pbk).&quot;
    New-Item &quot;$RequiredFolder\rasphone.pbk&quot; -ItemType File | Out-Null

    Write-Log &quot;New rasphone.pbk file has been created in $RequiredFolder.&quot;
    Set-Content &quot;$RequiredFolder\rasphone.pbk&quot; $PBKConfig

    Write-Log &quot;File rasphone.pbk has been populated with configuration details.&quot;
    Stop-Transcript | Out-Null
  }
}
#endregion&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Not much to be said about the above code - all we are doing is pushing out the contents of the *.PBK file to the correct location on the target machines. There is only one important thing to note - Iâ€™ve specifically replaced the name and guid from the *.PBK file with variable names to allow me to set them in the configuration at the top of the script. You donâ€™t need to do that yourself, but it makes the solution a little more â€œreusableâ€.&lt;/p&gt;

&lt;p&gt;You can see where they normally appear in the screenshot below (lines 1 &amp;amp; 10).&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/2020/11/image.png&quot; title=&quot;PBK Snippet&quot;&gt;&lt;img src=&quot;/assets/images/2020/11/image.png&quot; alt=&quot;PBK Snippet&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Alright, weâ€™ve deployed the VPN - but it still isnâ€™t automatically connecting. Letâ€™s go and figure that out.&lt;/p&gt;

&lt;p&gt;The key to this solution is found in the registry (as always). The auto connection settings can be found in the local machine hive path shown below.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;HKLM:\SYSTEM\CurrentControlSet\Services\RasMan\Config&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/2020/11/image-1.png&quot; title=&quot;VPN Registry&quot;&gt;&lt;img src=&quot;/assets/images/2020/11/image-1.png&quot; alt=&quot;VPN Registry&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;As you can see above, for my corporate VPN connection, we are setting a few key values - namely:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;AutoTriggerDisabledProfilesList&lt;/strong&gt; - A list of VPNs specifically set to not automatically connect (done manually by the user).&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;AutoTriggerProfileEntryName&lt;/strong&gt; - The Name of the VPN connection&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;AutoTriggerProfileGUID&lt;/strong&gt; - The HEX GUID of the VPN connection&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;AutoTriggerProfilePhonebookPath&lt;/strong&gt; - The path to the phonebook file&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;UserSID&lt;/strong&gt; - The SID of the user who has set the automatic connection.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Once we understand what is required to set the connection, all we need to do is fill out the data and store it in the correct registry location!&lt;/p&gt;

&lt;pre class=&quot;wp-block-code&quot; title=&quot;Connect Automatically&quot;&gt;&lt;code lang=&quot;powershell&quot; class=&quot;language-powershell line-numbers&quot;&gt;
#region Functions
function Convert-HexToByte {
  [cmdletbinding()]
  param (
    [string]$HexString
  )
  $splitString = ($HexString -replace '(..)','$1,').Trim(',')
  [byte[]]$hexified = $splitString.Split(',') | ForEach-Object { &quot;0x$_&quot;}
  return $hexified
}
function Set-ComputerRegistryValues {
  param (
      [Parameter(Mandatory = $true)]
      [array]$RegistryInstance
  )
  try {
      foreach ($key in $RegistryInstance) {
          $keyPath = $key.Path
          if (!(Test-Path $keyPath)) {
              Write-Host &quot;Registry path : $keyPath not found. Creating now.&quot; -ForegroundColor Green
              New-Item -Path $key.Path -Force | Out-Null
              Write-Host &quot;Creating item property: $($key.Name)&quot; -ForegroundColor Green
              New-ItemProperty -Path $keyPath -Name $key.Name -Value $key.Value -Type $key.Type -Force
          }
          else {
              Write-Host &quot;Creating item property: $($key.Name)&quot; -ForegroundColor Green
              New-ItemProperty -Path $keyPath -Name $key.Name -Value $key.Value -Type $key.Type -Force
          }
      }
  }
  catch {
      Throw $_.Exception.Message
  }
}
#endregion
#region Configure Always On
[string[]]$autoDisable = (Get-ItemPropertyValue $rasManKeyPath -Name AutoTriggerDisabledProfilesList) | ForEach-Object { if ($_ -ne $VPNName) { $_ }}
$regKeys = @(
  @{
    Path = $rasManKeyPath
    Name = 'AutoTriggerDisabledProfilesList'
    Value = [string[]]$autoDisable
    Type = 'MultiString'
  }
  @{
    Path = $rasManKeyPath
    Name = 'AutoTriggerProfilePhonebookPath'
    Value = &quot;$RequiredFolder\rasphone.pbk&quot;
    Type = 'String'
  }
  @{
    Path = $rasManKeyPath
    Name = 'AutoTriggerProfileEntryName'
    Value = $VPNName
    Type = 'String'
  }
@{
    Path = $rasManKeyPath
    Name = 'UserSID'
    Value = $sid
    Type = 'String'
  }
@{
    Path = $rasManKeyPath
    Name = 'AutoTriggerProfileGUID'
    Value = [Byte[]](Convert-HexToByte -HexString $VPNGUID)
    Type = 'Binary'
  }
)
Set-ComputerRegistryValues $regKeys
#endregion&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Again, most of this code is quite simple - all we are doing is entering some data into the registry.&lt;/p&gt;

&lt;p&gt;The only interesting thing of interest is how Iâ€™m converting the VPN GUID from the phonebook file into the Binary format required - which is done with the function &lt;strong&gt;Convert-HexToByte&lt;/strong&gt; show above - that took me a little longer than Iâ€™m willing to admit!&lt;/p&gt;

&lt;p&gt;The other thing to be aware of is that deploying the VPN config can be done either in the User or System context - no admin privileges are required, however due to the registry keys being stored in the HKLM hive, admin privileges will be required to set the â€œconnect automaticallyâ€ section of this solution.&lt;/p&gt;

&lt;p&gt;Thatâ€™s it for now - if youâ€™ve got any questions about this solution, please reach out to me on &lt;a href=&quot;https://twitter.com/powers_hell&quot;&gt;twitter&lt;/a&gt;, and as always, the code for this post can be found on my &lt;a href=&quot;https://github.com/tabs-not-spaces/CodeDump/tree/master/AzureVPNAutoConnect&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;â€” Ben&lt;/p&gt;</content><author><name>Ben</name></author><category term="Azure" /><category term="Intune" /><category term="PowerShell" /><category term="Intune" /><summary type="html">One of my clients recently came to me asking for assistance to set up a new VPN solution. The requirements were quite simple - They were building out an Azure Point-To-Site VPN solution and needed me to come up with a way to deliver the connection to the end user devices.</summary></entry><entry><title type="html">Deploying Universal Print Printers With PowerShell &amp;amp; Intune</title><link href="https://powers-hell.com/2020/10/25/deploying-universal-print-printers-with-powershell-intune/" rel="alternate" type="text/html" title="Deploying Universal Print Printers With PowerShell &amp;amp; Intune" /><published>2020-10-25T05:21:15+00:00</published><updated>2020-10-25T05:21:15+00:00</updated><id>https://powers-hell.com/2020/10/25/deploying-universal-print-printers-with-powershell-intune</id><content type="html" xml:base="https://powers-hell.com/2020/10/25/deploying-universal-print-printers-with-powershell-intune/">&lt;p&gt;Over the last few weeks Iâ€™ve been playing with &lt;strong&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/universal-print/fundamentals/universal-print-whatis&quot;&gt;Universal Print&lt;/a&gt;&lt;/strong&gt; - the cloud print solution developed by Microsoft and I honestly canâ€™t praise it enough.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;Configuring the â€œinfrastructureâ€ for the solution took me less than 5 minutes.. Seriously - Grab a license (free during the public preview), install and configure a connector on a device with line-of-sight to your printer and finally set the printer shares in the Azure portal.&lt;/p&gt;

&lt;p&gt;It was so easy I honestly donâ€™t think I need to talk more about it - &lt;a href=&quot;https://docs.microsoft.com/en-us/universal-print/fundamentals/universal-print-getting-started&quot;&gt;the steps are really well documented over on the Microsoft Docs page&lt;/a&gt;, so start there if you havenâ€™t already set things up.&lt;/p&gt;

&lt;p&gt;The one area that needs a little bit of polish is the way that printers get deployed to our end user devices. &lt;a href=&quot;https://docs.microsoft.com/en-us/universal-print/fundamentals/universal-print-intune-tool&quot;&gt;The current solution&lt;/a&gt; offered by Microsoft has two key requirements:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Deploy the &lt;strong&gt;Universal Print printer provisioning tool&lt;/strong&gt; via Intune (as a win32 package)&lt;/li&gt;
  &lt;li&gt;Deploy a CSV file with a list of printers, along with a batch script to deploy the CSV file to a key location.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Once the two packages are deployed, printers will then install on the client devices &lt;strong&gt;upon the next reboot or logon event&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Thereâ€™s two things I donâ€™t currently love about this solution and wanted to try and improve:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Is there a way we can make the printers install on the client devices without having to wait for a reboot or a logon event?&lt;/li&gt;
  &lt;li&gt;Can we do this with PowerShell?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The answer to both of these statements was a resounding â€œof course we can!â€ What I was surprised to find was how simple it actually was.&lt;/p&gt;

&lt;p&gt;This guide assumes youâ€™ve already configured everything else - licensing, setting up the Universal Print connector etc. If you havenâ€™t done that, go and sort that out.&lt;/p&gt;

&lt;p&gt;Alright, letâ€™s jump in - we are going to deploy this solution as a â€œproactive remediationâ€ script via Intune, although there is nothing stopping you deploying as a standard PowerShell script, or as a packaged win32 application.&lt;/p&gt;

&lt;h2 id=&quot;detection&quot;&gt;Detection&lt;/h2&gt;

&lt;pre title=&quot;Detection Script&quot; class=&quot;wp-block-code&quot;&gt;&lt;code lang=&quot;powershell&quot; class=&quot;language-powershell line-numbers&quot;&gt;#region printer list
$availablePrinters = @(
    &quot;Printer A&quot;
    &quot;Printer B&quot;
    &quot;Printer C&quot;
    &quot;Printer D&quot;
)
$notFound = 0
#endregion
#region check the printers exist
try {
    foreach ($p in $availablePrinters) {
        if (!(Get-Printer -Name $p -ErrorAction SilentlyContinue)) {
            $notFound ++
        }
    }
}
catch {
    $errorMsg = $_.Exception.Message
}
finally {
    if ($errorMsg) {
        Write-Warning $errorMsg
        exit 1
    }
    else {
        if ($notFound) {
            Write-Warning &quot;$notFound printers not found locally..&quot;
            exit 1
        }
        else {
            Write-Host &quot;All printers detected..&quot;
            exit 0
        }
    }
}
#endregion&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The code above is pretty simple, simply list the names of the printers you want to make sure exist on the device - if any of them are missing, they will be flagged and the script will exit with a &lt;strong&gt;non-zero&lt;/strong&gt; exit code, which will alert Intune that the remediation script is required to run.&lt;/p&gt;

&lt;h2 id=&quot;remediation&quot;&gt;Remediation&lt;/h2&gt;

&lt;pre title=&quot;Remediation Script&quot; class=&quot;wp-block-code&quot;&gt;&lt;code lang=&quot;powershell&quot; class=&quot;language-powershell line-numbers&quot;&gt;#region printer list
$availablePrinters = @(
    [pscustomobject]@{
        SharedID   = '2f8aa4d8-8c21-4d37-9506-3da446bcf9ea'
        SharedName = 'Printer A'
        IsDefault  = 'Yes'
    }
    [pscustomobject]@{
        SharedID   = 'c288bc70-8e14-4c5b-9f82-428ecf3ab63a'
        SharedName = 'Printer B'
        IsDefault  = $null
    }
    [pscustomobject]@{
        SharedID   = '478a29db-7bdd-46a7-a75e-e0d61167988c'
        SharedName = 'Printer C'
        IsDefault  = $null
    }
    [pscustomobject]@{
        SharedID   = '896262c5-59ca-4b92-becf-074feb25fccc'
        SharedName = 'Printer D'
        IsDefault  = $null
    }
)
#endregion
try {
    $configurationPath = &quot;$env:appdata\UniversalPrintPrinterProvisioning\Configuration&quot;
    if (!(Test-Path $configurationPath -ErrorAction SilentlyContinue)) {
        New-Item $configurationPath -ItemType Directory -Force | Out-Null
    }
    $printCfg = ($availablePrinters | ConvertTo-Csv -NoTypeInformation | ForEach-Object { $_ -replace '&quot;', &quot;&quot; } ) -join [System.Environment]::NewLine
    $printCfg | Out-File &quot;$configurationPath\printers.csv&quot; -Encoding ascii -NoNewline
    Start-Process &quot;${env:ProgramFiles(x86)}\UniversalPrintPrinterProvisioning\Exe\UPPrinterInstaller.exe&quot; -Wait -WindowStyle Hidden
}
catch {
    $errorMsg = $_.Exception.Message
}
finally {
    if ($errorMsg) {
        Write-Warning $errorMsg
        exit 1
    }
    else {
        Write-Host &quot;Universal Printer Installer configured and launched. Printers should appear shortly..&quot;
        exit 0
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The remediation script is also quite simple, the &lt;strong&gt;$availablePrinters&lt;/strong&gt; array contains the details of each Universal Print printer that we need to map the printer to the device.&lt;/p&gt;

&lt;p&gt;Head to &lt;strong&gt;Universal Print &amp;gt; Printer Shares&lt;/strong&gt; (In the Azure portal), select each printer share and make note of the &lt;strong&gt;Share ID&lt;/strong&gt; and the &lt;strong&gt;Name&lt;/strong&gt; of the share. For each printer, you will create a &lt;strong&gt;psCustomObject&lt;/strong&gt; containing the &lt;strong&gt;ShareID, SharedName&lt;/strong&gt; and whether or not you want this printer to be flagged as a &lt;em&gt;default&lt;/em&gt; printer or not.&lt;figure class=&quot;wp-block-image size-full&quot;&gt;&lt;/figure&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/2020/10/image-1.png&quot; title=&quot;Printer A&quot;&gt;&lt;img src=&quot;/assets/images/2020/10/image-1.png&quot; alt=&quot;Printer A&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The rest of the script is also fairly straight forward. What we are doing is building out the â€œprinters.csvâ€ file that the &lt;strong&gt;Universal Print Printer Provisioning Service&lt;/strong&gt; uses to validate which printers to install.&lt;/p&gt;

&lt;p&gt;The real &lt;em&gt;magic&lt;/em&gt; of the script (which isnâ€™t really that magic) is on line 32. The print provisioning service that gets installed by the Universal Print installation media sits in the background and listens for a &lt;strong&gt;user logon&lt;/strong&gt; event. Once this event is found, the service triggers another executable - &lt;strong&gt;UPPrinterInstaller.exe&lt;/strong&gt; which looks for the *.csv file we have created, authenticates to Graph, validates the print share details and then kicks off a &lt;strong&gt;Web Services for Devices (WSD)&lt;/strong&gt; process to map the available printers.&lt;/p&gt;

&lt;p&gt;Now, Iâ€™ll be the first to admit that the solution here is a little â€œkludgyâ€ - I initially intended to reverse engineer the &lt;strong&gt;UPPrinterInstaller.exe&lt;/strong&gt; to identify exactly &lt;em&gt;how&lt;/em&gt; that WSD process works, however this works well enough - for now at least.&lt;/p&gt;

&lt;h2 id=&quot;notes&quot;&gt;Notes&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;the Proactive Remediation detection and remediation scripts need to be run in the &lt;strong&gt;user context&lt;/strong&gt; as opposed to system - make sure you set that in the solution.&lt;/li&gt;
  &lt;li&gt;The default printer value will &lt;strong&gt;NOT&lt;/strong&gt; work the way it is intended if you have the &lt;strong&gt;Let Windows manage my default printer&lt;/strong&gt; setting enabled (found within the &lt;strong&gt;Printers &amp;amp; scanners&lt;/strong&gt; section of settings). Which makes sense - but just be aware of that.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I will continue to dig into this solution to try and make it a little more elegant - with the hopes that any advancements I make with the provisioning process might just make it into the official solution once it leaves Public Preview.&lt;/p&gt;

&lt;p&gt;As always, the code referenced in this guide is available in &lt;a href=&quot;https://github.com/tabs-not-spaces/CodeDump/tree/master/Universal-Print-Printer-Install&quot;&gt;GitHub&lt;/a&gt; and I can be reached on &lt;a href=&quot;https://twitter.com/powers_hell&quot;&gt;Twitter&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;â€” Ben&lt;/p&gt;</content><author><name>Ben</name></author><category term="Azure" /><category term="Graph" /><category term="Intune" /><category term="PowerShell" /><category term="Universal Print" /><category term="Intune" /><category term="PowerShell" /><category term="Universal Print" /><summary type="html">Over the last few weeks I've been playing with **Universal Print** - the cloud print solution developed by Microsoft and I honestly can't praise it enough.</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://powers-hell.com/assets/images/2020/10/universalprint.gif" /><media:content medium="image" url="https://powers-hell.com/assets/images/2020/10/universalprint.gif" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Preparing custom image templates with Azure Image Builder &amp;amp; PowerShell</title><link href="https://powers-hell.com/2020/09/20/preparing-custom-image-templates-with-azure-image-builder-powershell/" rel="alternate" type="text/html" title="Preparing custom image templates with Azure Image Builder &amp;amp; PowerShell" /><published>2020-09-20T10:44:14+00:00</published><updated>2020-09-20T10:44:14+00:00</updated><id>https://powers-hell.com/2020/09/20/preparing-custom-image-templates-with-azure-image-builder-powershell</id><content type="html" xml:base="https://powers-hell.com/2020/09/20/preparing-custom-image-templates-with-azure-image-builder-powershell/">&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/azure/virtual-machines/windows/image-builder-overview&quot;&gt;Azure Image Builder&lt;/a&gt; (AIB) is Microsoftâ€™s solution to configure and customize virtual machine images. The concept of it is pretty great: Pick a reference image from the public market place, apply some customization built around &lt;a href=&quot;https://www.packer.io/&quot;&gt;HashiCorpâ€™s Packer&lt;/a&gt;, hit build and what you are left with is a fully customized template image that can be hosted in Azure as a managed image or a VHD file.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;Now, hereâ€™s the problem - AIB is still very much in preview and is tricky to set up. Thereâ€™s lots of &lt;a href=&quot;http://xenithit.blogspot.com/2020/06/using-azure-image-builder-and-azure.html&quot;&gt;great guides&lt;/a&gt; on how to set up your tenant to use AIB, but I wanted to try and simplify the initial configuration of your tenant so you can get past the â€œpreview hurdlesâ€ and just get straight into building your image templates.&lt;/p&gt;

&lt;p&gt;So, I went and published a â€œhelperâ€ module to do just that! &lt;a href=&quot;https://www.powershellgallery.com/packages/az.imagebuilder.tools&quot;&gt;Az.ImageBuilder.Tools&lt;/a&gt; is a module that will assist you with configuring your tenant to enable the features, custom roles and managed identities required to start playing with AIB.&lt;/p&gt;

&lt;p&gt;Letâ€™s dive right in - by the end of this guide, we will be able to:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Set up our tenant to use AIB and Shared Image Gallery (SIB)&lt;/li&gt;
  &lt;li&gt;Build the AIB template from the Win10 EVD (multi session) image from the Azure Marketplace&lt;/li&gt;
  &lt;li&gt;Add a customization script to pre-install software to our AIB template&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;All right - letâ€™s get into it!&lt;/p&gt;

&lt;h2 id=&quot;pre-requirements&quot;&gt;Pre-Requirements&lt;/h2&gt;

&lt;h3 id=&quot;grab-the-modules&quot;&gt;Grab the modules&lt;/h3&gt;

&lt;p&gt;First, letâ€™s install the &lt;a href=&quot;https://www.powershellgallery.com/packages/az.imagebuilder.tools&quot;&gt;Az.ImageBuilder.Tools&lt;/a&gt; module - this will not only install my helper module, but all other required pre-req modules.&lt;/p&gt;

&lt;pre class=&quot;wp-block-code&quot;&gt;&lt;code lang=&quot;powershell&quot; class=&quot;language-powershell line-numbers&quot;&gt;Install-Module Az.ImageBuilder.Tools&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;authenticate-to-your-tenant&quot;&gt;Authenticate to your tenant&lt;/h3&gt;

&lt;p&gt;Make sure you are connected to your tenant!&lt;/p&gt;

&lt;pre class=&quot;wp-block-code&quot;&gt;&lt;code lang=&quot;powershell&quot; class=&quot;language-powershell line-numbers&quot;&gt;
#region Connect to Azure
Connect-AzAccount
$azContext = Get-AzContext
$subscriptionID = $azContext.Subscription.Id
#endregion
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;enable-the-features-and-providers-required-for-aib--sig&quot;&gt;Enable the features and providers required for AIB / SIG&lt;/h3&gt;

&lt;p&gt;This one is going to take a minute - run the below command and check back in 15..&lt;/p&gt;

&lt;pre class=&quot;wp-block-code&quot;&gt;&lt;code lang=&quot;powershell&quot; class=&quot;language-powershell line-numbers&quot;&gt;Invoke-AIBProviderCheck&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Run the same command in 15~ minutes to verify the features and providers are registered. If you donâ€™t want to do this step, add &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-wait&lt;/code&gt; to the command. Once everything is ready, you should see the below.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/2020/09/invoke-aibprovidercheck.gif&quot; title=&quot;Imvoke-AIBProvider&quot;&gt;&lt;img src=&quot;/assets/images/2020/09/invoke-aibprovidercheck.gif&quot; alt=&quot;Imvoke-AIBProvider&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;define-the-variables&quot;&gt;Define the variables&lt;/h2&gt;

&lt;p&gt;You donâ€™t need to set these up, but câ€™mon - this guide is clearly setting you up for an automated template processâ€¦ so letâ€™s go ahead and treat it like that.&lt;/p&gt;

&lt;pre class=&quot;wp-block-code&quot;&gt;&lt;code lang=&quot;powershell&quot; class=&quot;language-powershell line-numbers&quot;&gt;$resourceGroupName = 'AIB-ResourceGroup'
$location = 'eastus'
$imageTemplateName = 'Win10-20H1-EVD'
$sharedGalleryName = 'SharedImageGallery'
$imageDefinitionName = 'Win10EVD'
$runOutputName = 'winClientR01'
$imageConfig = @{
    OsState   = 'generalized'
    OsType    = 'Windows'
    Publisher = 'MicrosoftWindowsDesktop'
    Offer     = 'office-365'
    Sku       = '20h1-evd-o365pp'
    Version   = 'latest'
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A few notes on the variables above:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The values in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$imageConfig&lt;/code&gt; are set specifically for the current build of the Win10 EVD image from the marketplace - donâ€™t change those unless you know there is a new version.&lt;/li&gt;
  &lt;li&gt;Everything else is fair game - &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$resourceGroupName&lt;/code&gt; defines the name of the resource group you want to put the AIB / SIG resources into - if it doesnâ€™t exist, donâ€™t worry - the next step will sort that out.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;initialize-azure-image-builder-aib&quot;&gt;Initialize Azure Image Builder (AIB)&lt;/h2&gt;

&lt;p&gt;Now we need to create the custom roles and managed identity - these are the steps that stop most people from moving ahead - no worry, Iâ€™ve sorted it out.&lt;/p&gt;

&lt;pre class=&quot;wp-block-code&quot;&gt;&lt;code lang=&quot;powershell&quot; class=&quot;language-powershell line-numbers&quot;&gt;$mIDParams = @{
    AzureContext      = $azContext
    ResourceGroupName = $resourceGroupName
    Location          = $location
    IdentityName      = 'aibIdentity'
}
$managedIdentity = Initialize-AzureImageBuilder @mIDParams&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This command will create the resource group if its missing, create a managed identity and apply custom roles required to work with AIB / SIG.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/2020/09/initialize-azureImageBuilder.gif&quot; title=&quot;Initializa-AzureImageBuilder&quot;&gt;&lt;img src=&quot;/assets/images/2020/09/initialize-azureImageBuilder.gif&quot; alt=&quot;Initializa-AzureImageBuilder&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;create-the-shared-image-gallery-sig&quot;&gt;Create the Shared Image Gallery (SIG)&lt;/h2&gt;

&lt;p&gt;AIB allows us to host our image templates as VHDs or in a &lt;a href=&quot;https://docs.microsoft.com/en-us/azure/virtual-machines/windows/shared-image-galleries&quot;&gt;Shared Image Gallery&lt;/a&gt; - I wonâ€™t go into what SIG is here, but for the sake of clarity - SIG is a great solution to store and manage image templates.&lt;/p&gt;

&lt;pre class=&quot;wp-block-code&quot;&gt;&lt;code lang=&quot;powershell&quot; class=&quot;language-powershell line-numbers&quot;&gt;$azGalleryParams = @{
    Name              = $sharedGalleryName
    ResourceGroupName = $resourceGroupName
    Location          = $location
}
New-AzGallery @azGalleryParams&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;prepare-the-source-image&quot;&gt;Prepare the source image&lt;/h2&gt;

&lt;p&gt;Ok, we are going to set up the source image and the definitions - nothing too exciting here. The commands and their parameters should be self-explanatory.&lt;/p&gt;

&lt;pre class=&quot;wp-block-code&quot;&gt;&lt;code lang=&quot;powershell&quot; class=&quot;language-powershell line-numbers&quot;&gt;# create the source image
$srcObjParams = @{
    SourceTypePlatformImage = $true
    Publisher               = $imageConfig.Publisher
    Offer                   = $imageConfig.Offer
    Sku                     = $imageConfig.Sku
    Version                 = $imageConfig.Version
}
$srcPlatform = New-AzImageBuilderSourceObject @srcObjParams
# create the image definition
$imageDefParams = @{
    GalleryName       = $sharedGalleryName
    ResourceGroupName = $resourceGroupName
    Location          = $location
    Name              = $imageDefinitionName
    OsState           = $imageconfig.OsState
    OsType            = $imageConfig.OsType
    Publisher         = ([mailaddress]$azContext.account.id).Host
    Offer             = $imageConfig.Offer
    Sku               = $imageConfig.Sku
}
New-AzGalleryImageDefinition @imageDefParams
# create the distributor object
$distObjParams = @{
    SharedImageDistributor = $true
    ArtifactTag            = @{ tag = 'dis-share' }
    GalleryImageId         = &quot;/subscriptions/$subscriptionID/resourceGroups/$resourceGroupName/providers/Microsoft.Compute/galleries/$sharedGalleryName/images/$imageDefinitionName&quot;
    ReplicationRegion      = $location
    RunOutputName          = $runOutputName
    ExcludeFromLatest      = $false
}
$disSharedImg = New-AzImageBuilderDistributorObject @distObjParams&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;add-customization&quot;&gt;Add customization&lt;/h2&gt;

&lt;p&gt;Hereâ€™s the secret sauce - you can add as many customization objects as you want to this. Itâ€™s documented well - go check it out. But for now, Iâ€™ve hosted a simple PowerShell script on GitHub and Iâ€™m going to use that as my single customization step.&lt;/p&gt;

&lt;pre class=&quot;wp-block-code&quot;&gt;&lt;code lang=&quot;powershell&quot; class=&quot;language-powershell line-numbers&quot;&gt;# Add customizer step
$imgCustomParams = @{
    PowerShellCustomizer = $true
    CustomizerName       = 'MountAppShareAndRunInstaller'
    RunElevated          = $true
    scriptUri            = 'https://raw.githubusercontent.com/tabs-not-spaces/Az.ImageBuilder.Tools/master/Samples/AppInstall.ps1'
}
$customizer = New-AzImageBuilderCustomizerObject @imgCustomParams&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;combine-all-the-ingredients&quot;&gt;Combine all the ingredients..&lt;/h2&gt;

&lt;p&gt;Now we have our shared image gallery, source object, distributor object, image definition and customization steps - letâ€™s add them all together and prep the template.&lt;/p&gt;

&lt;pre class=&quot;wp-block-code&quot;&gt;&lt;code lang=&quot;powershell&quot; class=&quot;language-powershell line-numbers&quot;&gt;# Create AIB Template
$imgTemplateParams = @{
    ImageTemplateName      = $imageTemplateName
    ResourceGroupName      = $resourceGroupName
    Source                 = $srcPlatform
    Distribute             = $disSharedImg
    Customize              = $customizer
    Location               = $location
    UserAssignedIdentityId = $managedIdentity.ResourceId
}
New-AzImageBuilderTemplate @ImgTemplateParams&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is going to take a little while - around 10 minutes. Keep an eye on the status of the task with the following command.&lt;/p&gt;

&lt;pre class=&quot;wp-block-code&quot;&gt;&lt;code lang=&quot;powershell&quot; class=&quot;language-powershell line-numbers&quot;&gt;Get-AzImageBuilderTemplate -ImageTemplateName $imageTemplateName -ResourceGroupName $resourceGroupName&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;build-the-template&quot;&gt;Build the template&lt;/h2&gt;

&lt;p&gt;Everything is ready - now we just need to kick off the build - again, this is going to take a while. From my experience, Iâ€™ve found it takes anywhere from 15 minutes to an Hour - it entirely depends on what customization options you are adding.&lt;/p&gt;

&lt;pre class=&quot;wp-block-code&quot;&gt;&lt;code lang=&quot;powershell&quot; class=&quot;language-powershell line-numbers&quot;&gt;# Start the template build task
# check back on the $job variable for the build status
$job = Start-AzImageBuilderTemplate -ResourceGroupName $resourceGroupName -Name $imageTemplateName -AsJob&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If your customization script stalls or is written in a way that canâ€™t bomb out elegantly, you may find yourself in a situation where the build process stalls - the image builder template process will time out after 4 hours by default. This can be changed.&lt;/p&gt;

&lt;p&gt;While this step is running, you can monitor the process in one of 3 ways.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;check on the status of the $job variable - while itâ€™s running itâ€™ll advise you. Same for when itâ€™s completed.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/2020/09/start-azimagebuildertemplate.gif&quot; title=&quot;Start-AzImageBuilderTemplate&quot;&gt;&lt;img src=&quot;/assets/images/2020/09/start-azimagebuildertemplate.gif&quot; alt=&quot;Start-AzImageBuilderTemplate&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Check the build status directly from the AIB API&lt;/li&gt;
&lt;/ul&gt;

&lt;pre class=&quot;wp-block-code&quot;&gt;&lt;code lang=&quot;powershell&quot; class=&quot;language-powershell line-numbers&quot;&gt;Get-AIBBuildStatus -AzureContext $azContext -ResourceGroupName $resourceGroupName -ImageTemplateName $imageTemplateName&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/2020/09/get-aibbuildstatus.gif&quot; title=&quot;Get-AIBBuildStatus&quot;&gt;&lt;img src=&quot;/assets/images/2020/09/get-aibbuildstatus.gif&quot; alt=&quot;Get-AIBBuildStatus&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Finally, you can check the &lt;strong&gt;VERY&lt;/strong&gt; verbose logs of packer - jump into your resource groups list - youâ€™ll see a new resource group similarly named to the resource group you defined at the start of this guide.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/2020/09/image-1.png&quot; title=&quot;AIB Resource Group&quot;&gt;&lt;img src=&quot;/assets/images/2020/09/image-1.png&quot; alt=&quot;AIB Resource Group&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Inside the storage account, there will be a container named &lt;strong&gt;packerlogs.&lt;/strong&gt; click through the packerlogs container and the internal randomly generated folder and monitor the &lt;strong&gt;customization.log&lt;/strong&gt; file. Thereâ€™s &lt;a href=&quot;https://docs.microsoft.com/en-us/azure/virtual-machines/linux/image-builder-troubleshoot#customization-log&quot;&gt;good documentation&lt;/a&gt; on this, and itâ€™s going to help you out if you need to troubleshoot your customization script.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Once your template is built - you are done! You now have a customized template that you can use to build out virtual machinesâ€¦ or if you are paying attention - session hosts for Windows Virtual Desktop!&lt;/p&gt;

&lt;p&gt;Stay tuned for a post on how to build WVD session hosts using AIB and PowerShell!&lt;/p&gt;

&lt;p&gt;As always, sample code used in this guide are available on &lt;a href=&quot;https://github.com/tabs-not-spaces/Az.ImageBuilder.Tools/tree/master/Samples&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;â€” Ben&lt;/p&gt;</content><author><name>Ben</name></author><category term="Azure" /><category term="PowerShell" /><category term="Automation" /><category term="WVD" /><category term="Azure Image Builder" /><category term="PowerShell" /><category term="Automation" /><category term="WVD" /><summary type="html">AIB is Microsoft's solution to configure and customize virtual machine images. The concept of it is pretty great.. pick a reference image from the public market place apply some customization built around HashiCorp's Packer hit build and what you are left with is a fully customized template image that can be hosted in Azure as a managed image or a VHD file.</summary></entry><entry><title type="html">Dynamically set the time zone of a device in Intune using Azure Maps &amp;amp; PowerShell</title><link href="https://powers-hell.com/2020/08/31/setting-the-time-zone-of-an-intune-managed-device-using-azure-maps-powershell/" rel="alternate" type="text/html" title="Dynamically set the time zone of a device in Intune using Azure Maps &amp;amp; PowerShell" /><published>2020-08-30T21:20:59+00:00</published><updated>2020-08-30T21:20:59+00:00</updated><id>https://powers-hell.com/2020/08/31/setting-the-time-zone-of-an-intune-managed-device-using-azure-maps-powershell</id><content type="html" xml:base="https://powers-hell.com/2020/08/31/setting-the-time-zone-of-an-intune-managed-device-using-azure-maps-powershell/">&lt;p&gt;Let me start off by saying I wish I didnâ€™t have to write this post. Setting the correct time zone of a Windows device shouldnâ€™t be this difficult, especially with all of the management possibilities provided to us with Intune and the entire endpoint management stack. But here we are!&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;I get it though. At one point, as &lt;a href=&quot;https://twitter.com/mniehaus&quot;&gt;Michael Neihaus&lt;/a&gt; &lt;a href=&quot;https://oofhours.com/2019/12/20/configuring-time-zones-part-2/&quot;&gt;has written about previously&lt;/a&gt;, even if we could configure the time zone during the Out of Box Experience, everything was hinged on the timings of certificates and policies reaching the device within an agreed time frame.
If the time zone changed on a device during that process it had the possibility to break the entire enrollment process. This has since been (for the most part) resolved if you are using Windows 10 2004 (20h1) as your operating system.&lt;/p&gt;

&lt;p&gt;Iâ€™m hopeful that eventually, we will be able to configure the time zone as part of the OOBE, but until that time comes, Iâ€™d like to share some ways that I currently solve this problem using Azure Maps &amp;amp; PowerShell.&lt;/p&gt;

&lt;p&gt;Most solutions Iâ€™ve found involve creating custom OMA-URI policies to set the value of the time zone which works in some scenarios, but isnâ€™t elegant enough to handle the real world problem of managing devices and users located all over the world. So letâ€™s change that.&lt;/p&gt;

&lt;h2 id=&quot;setting-time-zone-from-device-gps-data&quot;&gt;Setting time zone from device GPS data&lt;/h2&gt;

&lt;p&gt;This one is fun but does require that &lt;strong&gt;location services&lt;/strong&gt; are turned on which, by default are disabled. This can be enforced by device configuration policies, but there are obvious security implications and you may need to discuss this with your organization before enabling.&lt;/p&gt;

&lt;p&gt;The solution below converts the GPS latitude and longitude data to the required windows time zone data by using an API available through Azure Maps.&lt;/p&gt;

&lt;p&gt;Pricing is super affordable and the â€œincluded free quantityâ€ means that for small to medium-sized businesses, there is a chance youâ€™d end up not paying a cent. For reference, here are the available &lt;a href=&quot;https://docs.microsoft.com/en-us/azure/azure-maps/choose-pricing-tier&quot;&gt;plans&lt;/a&gt; and &lt;a href=&quot;https://azure.microsoft.com/en-us/pricing/details/azure-maps/&quot;&gt;pricing&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;configuring-azure-maps&quot;&gt;Configuring Azure Maps&lt;/h3&gt;

&lt;p&gt;This is super easy, but itâ€™s still worth documenting!&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Open up your Azure portal and create a new resource.&lt;/li&gt;
  &lt;li&gt;Search the marketplace for â€œAzure Mapsâ€ and create an account.&lt;/li&gt;
  &lt;li&gt;Fill out the relevant fields and choose your pricing tier (as mentioned above, S0 will be &lt;strong&gt;more&lt;/strong&gt; than enough for this demo.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/2020/08/image-4.png&quot; title=&quot;Create Azure Maps Account&quot;&gt;&lt;img src=&quot;/assets/images/2020/08/image-4.png&quot; alt=&quot;Create Azure Maps Account&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Once the account is created, go to the resource and head to the &lt;strong&gt;Authentication&lt;/strong&gt; page. Make note of one of the &lt;strong&gt;Shared Keys&lt;/strong&gt;. We will use these to authenticate to the service.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;writing-the-code&quot;&gt;Writing the code&lt;/h3&gt;

&lt;p&gt;Now letâ€™s grab our GPS data and send it to the Azure Maps API!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-PowerShell&quot;&gt;Add-Type -AssemblyName System.Device
$gw = New-Object System.Device.Location.GeoCoordinateWatcher
$gw.Start()
while (($gw.Status -ne 'Ready') -and ($gw.Permission -ne 'Denied')) {
    Start-Sleep -Milliseconds 100 #Wait for discovery.
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above code is fairly simple - we are adding the &lt;strong&gt;System.Device&lt;/strong&gt; assembly to our session and creating and starting a new &lt;strong&gt;GeoCoordinateWatcher&lt;/strong&gt; object to capture the GPS data of our device.&lt;/p&gt;

&lt;p&gt;If we look at the results that are stored in the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$gw&lt;/code&gt; variable we should see the property name &lt;strong&gt;Permission&lt;/strong&gt;. If we step into that, we should see the location data required for the next step.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/2020/08/image-5.png&quot; title=&quot;$gw variable&quot;&gt;&lt;img src=&quot;/assets/images/2020/08/image-5.png&quot; alt=&quot;$gw variable&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Now that we have our Latitude and Longitude data stored in a variable, next we need to form the request to the Azure Maps API.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-PowerShell&quot;&gt;$apiKey = &quot;00000000000000000000000000&quot; #replace with your subscription Key
$baseUri = &quot;https://atlas.microsoft.com/timezone&quot;
$restParams = @{
    Method      = &quot;Get&quot;
    Uri         = &quot;$baseUri/byCoordinates/json?subscription-key=$apiKey&amp;amp;api-version=1.0&amp;amp;query=$($gw.Position.Location.Latitude),$($gw.Position.Location.Longitude)&quot;
    ContentType = 'Application/Json'
}
$locData = Invoke-RestMethod @restParams
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Looking at the contents of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$locData&lt;/code&gt; we should now see some cool data.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/2020/08/image-6.png&quot; title=&quot;location data&quot;&gt;&lt;img src=&quot;/assets/images/2020/08/image-6.png&quot; alt=&quot;location data&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Stepping into the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$locData.TimeZones&lt;/code&gt; property should give us even more info.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/2020/08/image-7.png&quot; title=&quot;Timezones data&quot;&gt;&lt;img src=&quot;/assets/images/2020/08/image-7.png&quot; alt=&quot;Timezones data&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The final step is to convert the value we see in &lt;strong&gt;Id&lt;/strong&gt; from the IANA code, to the format our computer needs to set the time zone.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-PowerShell&quot;&gt;$apiKey = '000000000000000000000000000000' #use a subscription key from your Azure Maps Account
$restParams = @{
    Method = 'Get'
    Uri = &quot;https://atlas.microsoft.com/timezone/enumWindows/json?subscription-key=$apiKey&amp;amp;api-version=1.0&quot;
    ContentType = 'Application/Json'
}
$tzList = Invoke-RestMethod @restParams
$result = $tzList | Where-Object { $locData.TimeZones.id -in $_.IanaIds }
Set-TimeZone -Id $result
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;All we are doing above is getting a list of Windows time zone IDs and matching them to the IANA time zone ID. Once we have a match, using the native &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Set-TimeZone&lt;/code&gt; allows us to dynamically set our device time zone with relative ease!&lt;/p&gt;

&lt;h2 id=&quot;setting-time-zone-from-public-ip-address&quot;&gt;Setting Time Zone from public IP address&lt;/h2&gt;

&lt;p&gt;So what if you arenâ€™t allowed to enable location services? Or what if you are provisioning virtual machines that donâ€™t have access to the GPS data? Luckily, there is another way to get our location data - from the publicly facing IP address of the device.&lt;/p&gt;

&lt;p&gt;For this example, we will use a free API from &lt;a href=&quot;https://ipinfo.io&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://ipinfo.io/&quot;&gt;https://ipinfo.io&lt;/a&gt;. You can use this API without registering, however, it is heavily rate-limited without providing an access token, so just register an account - it allows 50,000 API calls a month for free which is more than enough for this scenario.&lt;/p&gt;

&lt;p&gt;Once youâ€™ve registered and signed in, grab a copy of the access token from the dashboard - we will use it below.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-PowerShell&quot;&gt;$apiKey = '000000000000000000000000000000' # replace with access key from your ipinfo.io account
$locData = Invoke-RestMethod &quot;https://ipinfo.io?token=$apiKey&quot; -ContentType 'Application/Json'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we look at the value of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$locData&lt;/code&gt; we should see similar data from our first example.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/2020/08/image-9.png&quot; title=&quot;$locData&quot;&gt;&lt;img src=&quot;/assets/images/2020/08/image-9.png&quot; alt=&quot;$locData&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Jackpot! The value of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$locData.timezone&lt;/code&gt; is a properly formatted IANA Id. We could reuse the code from the first example to match up the IANA Id to the Windows time zone Id - or we can save an API call and grab a copy of the results and compare them in the code. Letâ€™s see how that would look.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-PowerShell&quot;&gt;$tzList = @{
    #region snippet of the countr / iana code table
    &quot;Africa/Abidjan&quot;      = &quot;Greenwich Standard Time&quot;
    &quot;Africa/Accra&quot;        = &quot;Greenwich Standard Time&quot;
    &quot;Africa/Addis_Ababa&quot;  = &quot;E. Africa Standard Time&quot;
    &quot;Africa/Algiers&quot;      = &quot;W. Central Africa Standard Time&quot;
    &quot;Africa/Asmera&quot;       = &quot;E. Africa Standard Time&quot;
    &quot;Africa/Bamako&quot;       = &quot;Greenwich Standard Time&quot;
    &quot;Africa/Bangui&quot;       = &quot;W. Central Africa Standard Time&quot;
    &quot;Africa/Banjul&quot;       = &quot;Greenwich Standard Time&quot;
    &quot;Africa/Bissau&quot;       = &quot;Greenwich Standard Time&quot;
    &quot;Africa/Blantyre&quot;     = &quot;South Africa Standard&quot;
    #endregion
}
$windowsId = $tzList.Get_Item($locData.timezone)
if ($windowsId) {
    $result = $windowsId
}
else {
    $result = ($tzList.GetEnumerator() | Where-Object { $_.Key -like &quot;*$($locData.timezone)*&quot; }).Value
}
Write-Host &quot;Setting timezone to $result..&quot;
Set-TimeZone -Id $result
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Obviously, thatâ€™s a LOT more code (cut for readability), but it does save us another API call, which if we are deploying to tens of thousands of devices could in the end save us being charged for API use!&lt;/p&gt;

&lt;p&gt;I personally prefer and actually do use the second method for setting time zones as during my testing Iâ€™m invariably building VMs before I move to physical devices (sometimes I donâ€™t even end up onto physical devices!), so being able to get a rough estimate of the location-based on public IP is much more reliable.&lt;/p&gt;

&lt;p&gt;How you deploy this to your devices is up to personal preference and operational requirements of course. Iâ€™ve generally had success simply deploying as a configuration script where I am happy for it to only run once, however bundling this with a scheduled task to run once a week or once a month to maintain time zone reliability is another great option.&lt;/p&gt;

&lt;p&gt;Iâ€™ve polished up the code from this article and provided both solutions as ready to deploy scripts, go check them out on my &lt;a href=&quot;https://github.com/tabs-not-spaces/CodeDump/tree/master/Set-Timezone&quot;&gt;GitHub&lt;/a&gt; - just make sure to update the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$apiKey&lt;/code&gt; for either scenario you choose to utilize.&lt;/p&gt;

&lt;p&gt;â€” Ben&lt;/p&gt;</content><author><name>Ben</name></author><category term="Azure" /><category term="Intune" /><category term="PowerShell" /><category term="Intune" /><summary type="html">Let me start off by saying I wish I didnâ€™t have to write this post. Setting the correct time zone of a Windows device shouldnâ€™t be this difficult, especially with all of the management possibilities provided to us with Intune and the entire endpoint management stack. But here we are!</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://powers-hell.com/assets/images/2020/08/gpsdata.jpg" /><media:content medium="image" url="https://powers-hell.com/assets/images/2020/08/gpsdata.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Managing Intune with Graph, PowerShell 7 &amp;amp; MSAL</title><link href="https://powers-hell.com/2020/06/28/managing-intune-with-graph-powershell-7-msal/" rel="alternate" type="text/html" title="Managing Intune with Graph, PowerShell 7 &amp;amp; MSAL" /><published>2020-06-27T22:39:24+00:00</published><updated>2020-06-27T22:39:24+00:00</updated><id>https://powers-hell.com/2020/06/28/managing-intune-with-graph-powershell-7-msal</id><content type="html" xml:base="https://powers-hell.com/2020/06/28/managing-intune-with-graph-powershell-7-msal/">&lt;p&gt;So it seems we need to talk about Graph and authentication again..&lt;/p&gt;

&lt;p&gt;Recently, Microsoft announced an official &lt;a href=&quot;https://techcommunity.microsoft.com/t5/azure-active-directory-identity/update-your-applications-to-use-microsoft-authentication-library/ba-p/1257363&quot;&gt;â€œend of support timelineâ€ for Azure Active Directory Authentication Library (ADAL)&lt;/a&gt; which means, any scripts or automation workflows that you use will need to be migrated over to the newer Microsoft Authentication Libraries (MSAL).&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;There are many differences between the two libraries, but the workflows are very similar - a request is sent using the libraries for access to specific areas of Azure and an authentication token is sent back giving you the keys into your Azure tenant.&lt;/p&gt;

&lt;p&gt;While the announcement from Microsoft gives us a few years to move on, right now if you have moved your workloads over to PowerShell 7 (which you 100% should be), you may have noticed that working with ADAL is tricky.&lt;/p&gt;

&lt;p&gt;Lets have a look at that now - using &lt;a href=&quot;https://twitter.com/davefalkus&quot;&gt;Daveâ€™s&lt;/a&gt; &lt;a href=&quot;https://github.com/microsoftgraph/powershell-intune-samples/blob/master/LOB_Application/Win32_Application_Add.ps1&quot;&gt;sample code&lt;/a&gt;, letâ€™s try and authenticate using the â€œwell-knownâ€ Intune application in PowerShell 7.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/2020/06/adalauthPS7.gif&quot; title=&quot;failing authentication in pwsh7&quot;&gt;&lt;img src=&quot;/assets/images/2020/06/adalauthPS7.gif&quot; alt=&quot;failing authentication in pwsh7&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;And for reference, the same code in PowerShell 5.1.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/2020/06/adalauthPS5.gif&quot; title=&quot;passing auth in pwsh5.1&quot;&gt;&lt;img src=&quot;/assets/images/2020/06/adalauthPS5.gif&quot; alt=&quot;passing auth in pwsh5.1&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The primary issue here is that PowerShell 7 just doesnâ€™t natively support the old authentication libraries - you can work around it if you have your existing authentication scripts in a module that you import using the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-UseWindowsPowerShell&lt;/code&gt; compatibility flag, but thatâ€™s not an ideal scenario.&lt;/p&gt;

&lt;p&gt;So how do we authenticate successfully in PowerShell 7 then? With MSAL of course!&lt;/p&gt;

&lt;p&gt;For simplicities sake, I will not deep dive into manually creating MSAL requests, as luckily there is already a great module available to us on the PowerShell Gallery - &lt;a href=&quot;https://www.powershellgallery.com/packages/MSAL.PS&quot;&gt;MSAL.PS&lt;/a&gt; (Written by &lt;a href=&quot;https://github.com/jasoth&quot;&gt;Jason Thompson&lt;/a&gt;). So Letâ€™s go ahead and install that on our computer.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-PowerShell&quot;&gt;Install-Module MSAL.PS -Scope CurrentUser
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;One of the benefits of MSAL is that it has been designed from the ground up to be completely cross-platform compatible, which means we get a few new ways to authenticate to devices that are â€œinput constrainedâ€. This is called â€œdevice code flowâ€.&lt;/p&gt;

&lt;p&gt;Using the well-known Intune app id, lets try out Device Code Flow.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-PowerShell&quot;&gt;Get-MsalToken -ClientId 'd1ddf0e4-d672-4dae-b554-9d5bdfd93547' -TenantId 'powers-hell.com' -DeviceCode
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/2020/06/msalDeviceCode.gif&quot; title=&quot;device code flow&quot;&gt;&lt;img src=&quot;/assets/images/2020/06/msalDeviceCode.gif&quot; alt=&quot;device code flow&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This is pretty cool - adding &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-DeviceCode&lt;/code&gt; to our command generates a code that we can use on another device to authenticate â€œon behalf ofâ€ the initial requesting device.&lt;/p&gt;

&lt;p&gt;But what if we want to keep it â€œold schoolâ€ ? Can we just interactively authenticate?&lt;/p&gt;

&lt;p&gt;The answer to that is â€œYes. But not with the well-known Intune app id..â€&lt;/p&gt;

&lt;p&gt;Letâ€™s try it now..&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-PowerShell&quot;&gt;Get-MsalToken -ClientId 'd1ddf0e4-d672-4dae-b554-9d5bdfd93547' -TenantId 'powers-hell.com' -DeviceCode
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/2020/06/msalInteractiveFail.gif&quot; title=&quot;failing interactive auth&quot;&gt;&lt;img src=&quot;/assets/images/2020/06/msalInteractiveFail.gif&quot; alt=&quot;failing interactive auth&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;How annoying! But what does this error mean?&lt;/p&gt;

&lt;p&gt;Simply put, the reply URLs in the AAD application we went to try and authenticate are missing the specific reply URL that MSAL needs registered, which is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;http://localhost&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;So, what this means, is that until the maintainer of the â€œPowerShell Intuneâ€ application updates the app to include the correct scope, the only way we can use it with MSAL is by following the device code flow.&lt;/p&gt;

&lt;p&gt;Until that time, we can create our own AAD application with the same permissions contained within the well-known app and use that instead.&lt;/p&gt;

&lt;p&gt;For those interested in this, the permissions required are below.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;&lt;strong&gt;Intune Client Scope:&lt;/strong&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;DeviceManagementApps.ReadWrite.All&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;DeviceManagementConfiguration.ReadWrite.All&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;DeviceManagementManagedDevices.PrivilegedOperations.All&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;DeviceManagementManagedDevices.ReadWrite.All&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;DeviceManagementRBAC.ReadWrite.All&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;DeviceManagementServiceConfig.ReadWrite.All&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Directory.Read.All Group.Read.All&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Group.ReadWrite.All&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Iâ€™ve already gone ahead and created this in my tenant and will be using it for all of my existing workflows and tools.&lt;/p&gt;

&lt;p&gt;So now we have a new AAD application registered with the correct permission scopes AND the correct reply URL, letâ€™s see the authentication flow in a simple Graph call.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-PowerShell&quot;&gt;[cmdletbinding()]
param (
    [Parameter(Mandatory = $true)]
    [guid]$clientId,

    [Parameter(Mandatory = $true)]
    [string]$tenantId
)
#region Get the auth token and build the auth header
$auth = Get-MsalToken -ClientId $clientId -TenantId $tenantId -Interactive
$authHeader = @{Authorization = $auth.CreateAuthorizationHeader()}
#endregion

#region Build the request and return the ID and Name of all win32 apps
$baseGraphUri = &quot;https://graph.microsoft.com/beta/deviceappmanagement/mobileapps&quot;
$results = (Invoke-RestMethod -Method Get -Uri &quot;$baseGraphUri`?`$filter=isOf('microsoft.graph.win32LobApp')&quot; -Headers $authHeader -ContentType 'Application/Json').value
$results | Select-Object id, displayName
#endregion
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The code above is a very simple example that grabs the authentication interactively and then queries Intune for any Win32 applications that have been packaged. Letâ€™s see it in action..&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/2020/06/get-win32apps.gif&amp;quot;&quot; title=&quot;Get Win32 Apps&quot;&gt;&lt;img src=&quot;/assets/images/2020/06/get-win32apps.gif&amp;quot;&quot; alt=&quot;Get Win32 Apps&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Hopefully this has helped you understand the importance of migrating over to MSAL and gives you and idea how to begin migrating your workflows over to this new authentication library!&lt;/p&gt;

&lt;p&gt;For more light reading on MSAL and how to plan migrations away from ADAL, check the links below:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://techcommunity.microsoft.com/t5/azure-active-directory-identity/update-your-applications-to-use-microsoft-authentication-library/ba-p/1257363&quot;&gt;Update your applications to use Microsoft authentication library&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/azure/active-directory/develop/msal-overview&quot;&gt;MSAL Overview&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/azure/active-directory/develop/msal-migration&quot;&gt;MSAL Migration&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;As always, code from this blog is available &lt;a href=&quot;https://github.com/tabs-not-spaces/CodeDump/tree/master/Get-Win32AppsUsingMSAL&quot;&gt;on my GitHub&lt;/a&gt; and I can be reached on &lt;a href=&quot;https://twitter.com/powers_hell&quot;&gt;Twitter&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;â€” Ben&lt;/p&gt;</content><author><name>Ben</name></author><category term="Graph" /><category term="Intune" /><category term="PowerShell" /><category term="Intune" /><summary type="html">So it seems we need to talk about Graph and authentication again.. Recently, Microsoft announced an official â€œend of support timelineâ€ for Azure Active Directory Authentication Library (ADAL) which means, any scripts or automation workflows that you use will need to be migrated over to the newer Microsoft Authentication Libraries (MSAL).</summary></entry></feed>